package collections.map;


import others.entities.Employee_ForUseHashCode;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * This program demonstrates the use of a map with key type String and value type EmployeeRAF.
 *
 * @author Cay Horstmann
 * @version 1.12 2015-06-21
 */
public class ExampleHashMap {
    public static void main(String[] args) {
//----------------------------------------------------------------------------------------------------------------------------------------
        Map<String, Employee_ForUseHashCode> staff = new HashMap<>();
        staff.put("144-25-5464", new Employee_ForUseHashCode("Lee", "Amy", 29));
        staff.put("567-24-2546", new Employee_ForUseHashCode("Hacker", "Harry", 45));
        staff.put("157-62-7935", new Employee_ForUseHashCode("Cooper", "Gary", 53));
        staff.put("456-62-5527", new Employee_ForUseHashCode("Cruz", "Francesca", 25));
        // print all entries
        System.out.println(staff);
        /*Метод remove () удаляет элемент из отображения по заданному ключу*/
        // remove an entry
        staff.remove("567-24-2546");
        // replace an entry
        staff.put("456-62-5527", new Employee_ForUseHashCode("Miller", "Francesca", 40));
        // look up a value
//        System.out.println(staff.get("157-62-7935"));
//         iterate through all entries
        staff.forEach((k, v) -> System.out.println("key=" + k + ", value=" + v));

//-------------------------------------------------- putlfAbsent() -----------------------------------------------------
        /*Кроме того, можно сначала вызвать метод putlfAbsent(), как показано ниже. Этот метод вводит значение в
        отображение только в том случае, если соответствующий ключ в нем ранее отсутствовал.*/
//        Map<String, Integer> staff2 = new HashMap<>();
//        String character = "A";
//        staff2.put(character, 10);
//        System.out.println(staff2.putIfAbsent(character, 0));
//        staff2.put(character, staff2.get(character) + 1);
//        System.out.println(staff2);
        // Теперь точно известно, что операция будет выполнена успешно
        /*Но можно поступить еще лучше, вызвав метод merge (), упрощающий эту типичную операцию. Так, в результате вызова*/
//        System.out.println(staff2.merge(character, 1, Integer::sum));
//        System.out.println(staff2.merge("B", 1, Integer::sum));
        /*заданное слово word связывается со значением 1, если ключ ранее отсутствовал, в противном случае предыдущее
        значение соединяется со значением 1 по ссылке на метод  Integer::sum.*/
//        System.out.println(staff2);

//----------------------------------------------------- null -----------------------------------------------------------
//        // Может ли null использоваться в качестве ключа в Map?
//        Map<Integer, String> hashMap = new HashMap<>();
//        hashMap.put(null, "value");   // момент истины ... ошибки нет!
//        /*Ключи должны быть однозначными. Нельзя сохранить два значения по одинаковым ключам. Если дважды вызвать метод
//        put() с одним и тем же ключом, то второе значение заменит первое. По существу, метод put() возвращает предыдущее
//        значение, сохраненное по ключу, указанному в качестве его параметра.*/
//        // v etom slychai takoi klych uze est. No on ne dobavlaietsa v map a zameniaet mesto staroho klycha
//        hashMap.put(null, "value2");
//        System.out.println(hashMap.size());
//        System.out.println(hashMap.get(null));
//
//        /*  Что же происходит? Цитата из первоисточника:
//          При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер
//          корзины(номер ячейки массива), в которую попадет новый элемент. То есть получается, что вычисляется hash-code
//          от null… хммм. Но как же он вычисляется без объекта, без hashCode()? Мой ответ — не знаю, но дебаггер
//          показывает, что для null hash=0. Видимо где-то есть отдельная проверка.*/
//
//        // Дальше все без сюрпризов, другой объект с hash=0 попадает в ту же «корзину».
//        hashMap.put(0, "0");
//        System.out.println(hashMap.size());

//        // HashMap оперирует с null-ключом без каких-либо проблем. Его hash всегда равен 0
//        Map<Integer, Integer> hashMap1 = new HashMap();
//        hashMap1.put(null,  null);
//        System.out.println(hashMap1.get(null));   // результат null говорит нам, что значения по этому ключу нет,
//                                                  // значит и самого ключа тоже нет
//
//        System.out.println(hashMap1.containsKey(null)); // результат true: а ключ на самом деле есть, и значение тоже есть

//--------------------------------------------------- getOrDefault() ---------------------------------------------------
//        /*Если в отображении отсутствуют данные по указанному ключу, то метод get() возвращает пустое значение null.
//        Обрабатывать возвращаемое пустое значение не совсем удобно. Иногда для ключей, отсутствующих в отображении, вполне
//        подходит значение по умолчанию , и тогда можно воспользоваться методом getOrDefault() следующим образом:*/
//        Map<String, Integer> scores = new HashMap<>();
//        // получить нулевое значение, если идентификатор отсутствует
//        System.out.println(scores.getOrDefault("key", 0));
//        System.out.println(scores);

//--------------------------------------------------------------------------------------------------------------------------------------
//        Map<Integer, String> hashMap = new HashMap<>();
//        Map<Integer, String> hashMap2 = new HashMap<>();
//        hashMap.put(3, "c");
//        hashMap.put(2, "d");
//        hashMap.put(4, "b");
//        hashMap.put(1, "e");
//        hashMap.put(5, "a");
//        for(Map.Entry<Integer, String> map: hashMap.entrySet()){
//            System.out.println(map.getKey() + ", " + "\"" + map.getValue() + "\"");
//        }
//        // Vnimanie eto ne otsorterirovanui spisok, eto hashCode() integera vozvrawchaet prosto znachenie

//--------------------------------------------------------------------------------------------------------------------------------------
        // Create age hash map.
        HashMap<String, Double> hashMap03 = new HashMap<String, Double>();

        // Put elements to the map
        hashMap03.put("John Doe", 3434.34);
        hashMap03.put("Tom Smith", 123.22);
        hashMap03.put("Jane Baker", 1378.00);
        hashMap03.put("Tod Hall", 99.22);
        hashMap03.put("Ralph Smith", -19.08);

        // Get age set of the entries.
        Set<Map.Entry<String, Double>> set = hashMap03.entrySet();

        // Display the set.
//        for(Map.Entry<String, Double> me : set) {
//            System.out.print(me.getKey() + ": ");
//            System.out.println(me.getValue());
//        }
//        System.out.println();

        // Deposit 1000 into John Doe's account.
        double balance = hashMap03.get("John Doe");
        hashMap03.put("John Doe", balance + 1000);
//        System.out.println("John Doe's new balance: " + hashMap03.get("John Doe"));

//--------------------------------------------------------------------------------------------------------------------------------------
    }
}




/*
----------------------------------------------------------------------------------------------------------------------------------------
Ostorozno zdes esli nado zberihat class "zdelanui vlasnorychno" v HashMap()
to nado realizovat metod hashCode(), potomy chto esli ne realizovat metod hashCode() to
ne polychica soxranennie v vide xewei a v vide sviaznoho spiska (polychitsa chtoto poxozoe na LinkedList)
----------------------------------------------------------------------------------------------------------------------------------------
Этот класс расширяет класс Ab s t ra ctMap и реализует интерфей с Ма р . В нем и с ­
пользуется хеш-таблица для хранения отображения , и б л агодаря этому о бе с п ечи ­
вается постоянное время выполнения методов g e t ( ) и put ( ) даже в обра щ е нии
к крупным отображениям.

Следует иметь в виду, что хеш-отображение не
гарантирует порядок расположения своих элементов. Следовательно, порядок,
в котором элементы вводятся в хеш-отображение, нс обязательно соответствует
тому порядку, в котором они извлекаются итератором.
----------------------------------------------------------------------------------------------------------------------------------------
 HashMap состоит из «корзин» (bucket`ов). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется за константное время. Вроде все здорово, с одной оговоркой, хеш-функций должна равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время.
---------------------------------------------------------------------------------------------------------------------------------------
ВНИМАНИЕ! Будьте внимательны и аккуратны, изменяя элементы хеш-множества. Если хеш-код элемента изменится, этот элемент
уже не будет находиться на правильной позиции в структуре данных.
---------------------------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Некоторых программистов удивляет, что в потокобезопасной, предположительно,
структуре данных разрешаются операции, не являющиеся потокобезопасными. Но этому имеют­
ся два совершенно противоположных объяснения. Если простое хеш -отображение типа HashMap
модифицируется в нескольких потоках исполнения, они могут нарушить его внутреннюю структуру
(т.е. массив связных списков). В итоге некоторые связи могут быть пропущены и даже зациклены,
приведя структуру данных в полную негодность. Ничего подобного не может произойти с хеш -о ­
тображением типа ConcurrentHashMap. В приведенном выше примере кода вызовы методов
get() и put() вообще не нарушают структуру данных. Но поскольку последовательность выпол­
няемых операций не является атомарной, то ее результат непредсказуем.
---------------------------------------------------------------------------------------------------------------------------------------
 HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n).

 HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка элементов с течением времени. Разрешение коллизий осуществляется с помощью метода цепочек.
---------------------------------------------------------------------------------------------------------------------------------------
 Начальное количество корзин в HashMap?

 16. Отвечая, стоит заметить, что можно используя конструкторы с параметрами:через параметр capacity задавать свое начальное количество корзин.
----------------------------------------------------------------------------------------------------------------------------------------
 Вы можете указать свои емкость и коэффициент загрузки, используя конструкторы HashMap(capacity) и HashMap(capacity, loadFactor). Максимальная емкость, которую вы сможете установить, равна половине максимального значения int (1073741824).
----------------------------------------------------------------------------------------------------------------------------------------
 Новоявленный объект hashmap, содержит ряд свойств:

    table — Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений;
    loadFactor — Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом                      хранимых данных;
    threshold — Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое. Рассчитывается по                  формуле (capacity * loadFactor);
    size — Количество элементов HashMap-а;
----------------------------------------------------------------------------------------------------------------------------------------
 Какая оценка временной сложности выборки элемента из HashMap?
 Гарантирует ли HashMap указанную сложность выборки элемента?

 Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то HashMap превратится в связный список, с отвратной производительностью. Затем даже, если вы будете использовать хеш-функцию с равномерным распределением, в предельном случае гарантироваться будет только временная сложность lg N. Так что, ответ на вторую часть вопроса — нет, не гарантируется.
-----------------------------------------------------------------------------------------------------------------------------------------
 Роль equals и hashCode в HashMap?

 HashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке внутри корзины и искомого ключа.
-----------------------------------------------------------------------------------------------------------------------------------------
Максимальное число значений hashCode()?

 Здесь все довольно просто, достаточно вспомнить сигнатуру метода: int hashCode(). То есть число значений равно диапазону типа int — 2^32 (точного диапазона никогда не спрашивали, хватало такого ответа).
-----------------------------------------------------------------------------------------------------------------------------------------
 Как и когда происходит увеличение количества корзин в HashMap?

 Помимо capacity в HashMap есть еще параметр loadFactor, на основании которого, вычисляется предельное количество занятых корзин (capacity*loadFactor). По умолчанию loadFactor = 0,75. По достижению предельного значения, число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.
------------------------------------------------------------------------------------------------------------------------------------------
 В каком случае может быть потерян элемент в HashMap?

 Все опять же оказалось довольно просто, хоть и не так явно: допустим в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хеш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals (ведь equals и hashCode должны работать с одним и тем же набором полей) уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хеш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет совсем в другую корзину и тогда он уже совсем потеряется.
-----------------------------------------------------------------------------------------------------------------------------------------
 Почему нельзя использовать byte[] в качестве ключа в HashMap?

 Как обычно, все оказалось довольно просто — хеш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хеш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Так же у массивов не переопределен equals и выполняет сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.
------------------------------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Начиная с версии Java SE 8, вместо связных списков в заполненных группах приме­
няются сбалансированные двоичные деревья. Благодаря этому повышается производительность,
если в результате неудачно выбранной хеш-функции возникает немало конфликтов или же если
в злонамеренном коде предпринимается попытка заполнить хеш-таблицу многими значениями
с одинаковыми хеш-кодами.
------------------------------------------------------------------------------------------------------------------------------------------
•
HashMap()
•
HashMap (int ini tialCapaci ty)
•
HashMap (int ini tialCapaci ty, float loadFactor)
Конструируют пустое хеш-отображение указанной емкости и с заданным коэффициентом загрузки
(числовым значением в пределах от 0 , 0 до 1 ,0 , определяющим процент заполнения хеш-табли­
цы, по достижении которого происходит повторное хеширование). Коэффициент загрузки по умол­
чанию равен 0,75.
•
default V merge (К key, V value, BiFunction<? super V,? super V,? extends V > remappingFunction) 8
Если указанный ключ key связан с непустым значением v, то применяет к значениям v h v a l ue за ­
данную функцию, а затем связывает указанный ключ key с получаемым результатом или удаляет этот
ключ, если в результате получается пустое значение null. Возвращает результат вызова get (key).
•
default V compute (К key, BiFunction<? super K,? super V,? extends V >
remappingFunction) 8
Применяет заданную функцию к указанному ключу key или к результату вызова g e t (key). Свя­
зывает указанный ключ key с получаемым результатом или удаляет этот ключ, если в результате
получается пустое значение n u l l . Возвращает результат вызова g e t ( fArgInt r e y ) .
•
default V computelfPresent(К key, BiFunction<? super K,? super V,?
extends V > remappingFunction) 8
Если указанный ключ key связан с непустым значением v, то применяет к этому ключу и зна­
чению v заданную функцию, а затем связывает указанный ключ key с получаемым результатом
или удаляет этот ключ, если в результате получается пустое значение n u l l . Возвращает результат
вызова g e t (key).
•
default V computelfAbsent (К key, Function<? super K,? extends V >
mappingFunction) 8
Применяет заданную функцию к указанному ключу key, если только этот ключ не связан с непу­
стым значением. Связывает указанный ключ key с получаемым результатом или удаляет этот ключ,
если в результате получается пустое значение n u l l . Возвращает результат вызова g e t( fc e y ) .
•
default void replaceAll(BiFunction<? super K,? super V,? extends V >
function) 8
Вызывает заданную функцию для всех записей в отображении. Связывает указанный ключ key
с не пустыми результатами и удаляет ключи с пустыми результатами.
•
Set<Map.EntryCK, V » entrySet ()
Возвращает представление множества объектов типа Map.Entry, т.е. пар “ кл ю ч-значение ” в ото­
бражении. Из этого множества можно удалять имеющиеся в нем элементы, но в него нельзя вво­
дить новые элементы.
•
Set<K> keyset ()
Возвращает представление множества всех ключей в отображении. Из этого множества можно
удалять имеющиеся в нем элементы, и в этом случае будут удалены ключи и связанные с ними
значения, но в него нельзя вводить новые элементы.
•
Collection<V> values()
Возвращает представление множества всех значений в отображении. Из этого множества можно
удалять имеющиеся в нем элементы, и в этом случае будут удалены значения и связанные с ними
ключи, но в него нельзя вводить новые элементы.
------------------------------------------------------------------------------------------------------------------------------------------



* */
