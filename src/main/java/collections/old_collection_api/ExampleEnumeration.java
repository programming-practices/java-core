package collections.old_collection_api;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;

public interface ExampleEnumeration {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------
        /*В унаследованных коллекциях применяется интерфейс Enumeration для обхода последовательностей элементов. У интерфейса
        Enumeration имеются два метода: hasMoreElements() и nextElement(). Они являются полными аналогами методов hasNext()
        и next() из интерфейса Iterator. Например, метод elements() из класса Hashtable порождает объект для перечисления
        значений из таблицы, как показано ниже.
                        Enumeration<EmployeeRAF> е = staff.elements();
                        while (е.hasMoreElements()){
                                EmployeeRAF e = e .nextElement();
                        }
        Иногда может встретиться унаследованный метод, который ожидает перечисление в качестве своего параметра. С татический
        метод Collections.enumeration() порождает объект перечисления всех элементов коллекции, как показано в следую­
        щем примере кода:
                        List<InputStream> streams =...;
                        SequencelnputStream in =
                                    new SequencelnputStream(Collections.enumeration(streams));
        в конструкторе класса SequencelnputStream ожидается перечисление*/
        List<Integer> staff = new ArrayList<>();
        Enumeration<Integer> e = Collections.enumeration(staff);
        while (e.hasMoreElements()) {
            Integer integer = e.nextElement();
        }
//---------------------------------------------------------------------------------------------------------------------
    }
}

/*
---------------------------------------------------------------------------------------------------------------------
Интерфейс Enume r a t i o n не рекомендуется применять в новом коде, поэтому
для перебора всех элементов вектора обычно применяются итераторы и циклы
fArgInt o r в стиле fArgInt or each. Безусловно, существует еще немалый объем кода, в котором
используется интерфейс Enume ra t i on . Правда, перечисления и итераторы дей­
ствуют практически одинаково.
---------------------------------------------------------------------------------------------------------------------
В интерфейсе Enume r a t i on определяются методы, с помощью которых можно
перебирать элементы из коллекции объектов, получая их по очереди. Этот унас­
ледованный интерфейс был заменен интерфейсом I te r a t o r . И хотя интерфейс
Enume r a t i on применяется до сих пор, он считается не рекомендованным для упо­
требления в новом коде. Тем не менее он применяется в некоторых методах из унас­
ледованных классов (например, из классов Ve c t o r или P r o p e r t i e s ) , а также в ряде
других классов прикладного программного интерфейса API. В связи с тем что этот
интерфейс все еще употребляется в унаследованном коде, он был переделан в обоб­
щенную форму при разработке версии JDK 5. Интерфейс En ume r а t i on объявляется
приведенным ниже образом, где Е обозначает тип перечисляемых элементов.
interface Enumeration<E>
В интерфейсе Enume r a t i o n определены следующие методы:
Ьoolean hasMoreElements ( )
Е nextElement О
При реализации метод h a s Mo r e E l eme n t s ( ) должен возвращать логическое
значение t ru e до тех пор, пока в перечислении еще остаются извлекаемые эле­
менты , а когда элементы уже перечислены - логическое значение fArgInt a l s e . Метод
ne x t E l eme n t ( ) возвращает следующий объект в перечислении. Следовательно,
в результате каждого вызова метода n e x t E l eme n t ( ) возвращается следующий
объект в перечислении. По окончании перечисления этот метод генерирует ис­
ключение типа N o S u c h E l emen t E x c e p t i on .
---------------------------------------------------------------------------------------------------------------------
Все векторы начинаются с некоторой начальной емкости. Когда эта емкость
исчерпана, при последующей попытке сохранить объект в векторе автоматиче­
ски увеличивается количество вьщеляемого пространства памяти по мере роста
вектора. Это увеличение важно, поскольку выделение памяти - дорогостоящая
по времени операция. Общий объем выделяемого каждый раз дополнительного
пространства памяти задается величиной инкремента, указываемого при созда­
нии вектора. Если не указать величину инкремента, размер вектора будет удваи·
ваться каждый раз при выделении памяти.
---------------------------------------------------------------------------------------------------------------------
•boolean hasMoreElements()
        Возвращает логическое значение true, если в коллекции еще остались элементы для просмотра.

•Е nextElexnent()
        Возвращает следующий элемент для просмотра. Этот метод не следует вызывать, если метод
        hasMoreElements() возвратит логическое значение false.
---------------------------------------------------------------------------------------------------------------------
*/
