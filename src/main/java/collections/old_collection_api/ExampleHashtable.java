package collections.old_collection_api;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;

public class ExampleHashtable {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------
        // Demonstrate age Hashtable.
        Hashtable<String, Double> hashtable = new Hashtable<String, Double>();

        Enumeration<String> enumeration;
        String str;
        double bal;

        hashtable.put("John Doe", 3434.34);
        hashtable.put("Tom Smith", 123.22);
        hashtable.put("Jane Baker", 1378.00);
        hashtable.put("Tod Hall", 99.22);
        hashtable.put("Ralph Smith", -19.08);

//        // Show all balances in hashtable.
//        enumeration = hashtable.keys();
//        while(enumeration.hasMoreElements()) {
//            str = enumeration.nextElement();
//            System.out.println(str + ": " + hashtable.get(str));
//        }
//
//        System.out.println();
//
//        // Deposit 1,000 into John Doe's account.
//        bal = hashtable.get("John Doe");
//        hashtable.put("John Doe", bal+1000);
//        System.out.println("John Doe's new balance: " +
//                hashtable.get("John Doe"));
//---------------------------------------------------------------------------------------------------------------------
        // Use iterators with age Hashtable.

        // Show all balances in hashtable.
        // First, get age set view of the keys.
        Set<String> set = hashtable.keySet();

        // Get an iterator.
        Iterator<String> itr = set.iterator();
        while (itr.hasNext()) {
            str = itr.next();
            System.out.println(str + ": " +
                    hashtable.get(str));
        }

        System.out.println();

        // Deposit 1,000 into John Doe's account.
        bal = hashtable.get("John Doe");
        hashtable.put("John Doe", bal + 1000);
        System.out.println("John Doe's new balance: " + hashtable.get("John Doe"));
//---------------------------------------------------------------------------------------------------------------------
    }
}

/*
------------------------------------------------------------------------------------------------------------------------
Класс H a s h t aЫ e входил еще в исходный пакет j ava . u t i l и является кон·
кретной реализацией класса D i c t i o n a r y. Но с появлением коллекций класс
H a s h t a Ы e был переделан таким образом, чтобы реализовать также интерфейс
Мар. Следовательно, класс На sh t а Ы е интегри рован в каркас коллекций Collections
Fraшework. Он подобен классу H a s hMap , но синхронизирован.
Подобно классу H a s hMap , класс H a s h t a Ы e служит для хранения пар "ключ­
значение" в хеш-таблице. Но ни ключи, ни значения не могут быть пустыми.
Используя класс Ha s h t a Ы e , следует указать объект, который служит ключом,
а также значение, которое требуется связать с этим ключом. Ключ затем хеши­
руется, а результирующий хеш-код используется в качестве индекса, по которому
значение сохраняется в таблице.
Класс H a s h t aЫ e был сделан обобщенным в версииJDК 5. Он объявляется п ри­
веденным ниже образом, где К обозначает тип ключей , а V - тип значений.
clas s HashtaЫe<K , V>
В хеш-таблице могут храниться объекты только тех классов, в которых переопре­
деляются методы h a shCode ( ) и equa l s ( ) , определенные в классе Ob j e c t . Метод
hashCode ( ) должен вычислять и возвращать хеш-код объекта, а метод e qual s ( ) -
сравнивать два объекта. П равда, во многих классах, встроенных в Java, метод
ha shCode ( ) уже реализован. Так, в наиболее распространенной хеш-таблице типа
H a s h t aЫ e в качестве ключа используется объект типа S t r ing. В классе S t r ing ре­
ализуются также методы ha s hCode ( ) и equa l s ( ) .
------------------------------------------------------------------------------------------------------------------------
 Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве
 значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии
 была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все
 методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью
 и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду
 отсутствия у них синхронизации.
------------------------------------------------------------------------------------------------------------------------
 Hashtable — потокобезопасная и легкая в использовании реализация хэш-таблицы. Проблема HashTable заключалась,
 в первую очередь, в том, что при доступе к элементам таблицы производилась её полная блокировка.
 Все методы Hashtable были синхронизированными. Это являлось серьёзным ограничением для многопоточной среды,
 поскольку плата за блокировку всей таблицы была очень большой.
------------------------------------------------------------------------------------------------------------------------
•Enumeration<K> keys()
        Возвращает объект перечисления, обходящий хеш-таблицу по всем ключам.

•Enumeration<V> elements()
        Возвращает объект перечисления, обходящий хеш-таблицу по всем значениям.
------------------------------------------------------------------------------------------------------------------------
*/

