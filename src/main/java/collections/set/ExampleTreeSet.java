package collections.set;

import java.util.*;

/**
 * This program sorts a set of item by comparing their descriptions.
 *
 * @author Cay Horstmann
 * @version 1.12 2015-06-21
 */
public class ExampleTreeSet {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------
        SortedSet<Item> parts = new TreeSet<>();
        parts.add(new Item("Toaster", 1234));
        parts.add(new Item("Widget", 4562));
        parts.add(new Item("Modem", 9912));
        System.out.println(parts);

        NavigableSet<Item> sortByDescription = new TreeSet<>(
                Comparator.comparing(Item::getDescription));

        sortByDescription.addAll(parts);
        System.out.println(sortByDescription);
//---------------------------------------------------------------------------------------------------------------------
//        // Create age tree set.
//        TreeSet<String> ts = new TreeSet<String>();
//
//        // Add elements to the tree set.
//        ts.add("C");
//        ts.add("A");
//        ts.add("B");
//        ts.add("E");
//        ts.add("F");
//        ts.add("D");
//
//        System.out.println(ts);
//
//        Iterator<String> iterator = ts.descendingIterator();
//        System.out.print("[");
//        while (iterator.hasNext()) {
//            System.out.print(iterator.next() + ", ");
//        }
//        System.out.println("]");
//---------------------------------------------------------------------------------------------------------------------
    }
}

/**
 * An item with a description and a part number.
 */
class Item implements Comparable<Item> {
    private String description;
    private int partNumber;

    /**
     * Constructs an item.
     *
     * @param aDescription the item's description
     * @param aPartNumber  the item's part number
     */
    public Item(String aDescription, int aPartNumber) {
        description = aDescription;
        partNumber = aPartNumber;
    }

    /**
     * Gets the description of this item.
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    //    public String toString() {
//        return "[description=" + description + ", partNumber=" + partNumber + "]";
//    }
    public String toString() {
        return "[" + description + " " + partNumber + "]";
    }

    public boolean equals(Object otherObject) {
        if (this == otherObject) return true;
        if (otherObject == null) return false;
        if (getClass() != otherObject.getClass()) return false;
        Item other = (Item) otherObject;
        return Objects.equals(description, other.description) && partNumber == other.partNumber;
    }

    public int hashCode() {
        return Objects.hash(description, partNumber);
    }

    public int compareTo(Item other) {
        int diff = Integer.compare(partNumber, other.partNumber);
        return diff != 0 ? diff : description.compareTo(other.description);
    }
}

/*
----------------------------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Чтобы пользоваться древовидным множеством, необходимо иметь возможность сравнивать его элементы. Для этого
элементы должны относиться к классу, реализующему интерфейс Comparable (см. раздел 6.1 .1), а иначе придется предоставить
объект типа Comparator при построении множества (см. раздел 6.3 .8).
----------------------------------------------------------------------------------------------------------------------------------------
Класс TreeS e t расширяет кЛасс AЬ s t r a c t S e t и реализует интерфейс
NavigaЬleSe t . Он создает коллекцию, где для хранения элементов применяет дре­
вовидная структура. Объекты сохраняются в отсортированном порядке по нарас­
тающей. Время доступа и извлечения элементов достаточно мало, благодаря чему
класс TreeSe t оказывается отличным выбором для хранения больших объемов от­
сортированных данных, которые должны быть быстро найдены.

TreeSet ( )
TreeSet (Collection<? extends Е> с)
TreeSet (Comparator<? super Е> comparator)
TreeSet ( SortedSet<E> ss)
В первой форме конструктора создается пустое древовидное множество, элемен­
ты которого будут отсортированы в естественном порядке по нарастающей. Во вто­
рой форме создается древовидное множество, содержащее элементы задан ной кол-
лекции с. В третьей форме создается пустое древовидное множество, элементы кото­
рого будуг отсортированы заданным компара тором. (Компараторы рассматриваются
далее в этой главе. ) И наконец, в четвертой форме создается древовидное множество,
содержащее элементы заданного отсортированного множества s s .
----------------------------------------------------------------------------------------------------------------------------------------
 TreeSet — аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает
 его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо
 сохраняет элементы с использованием "natural ordering".
----------------------------------------------------------------------------------------------------------------------------------------
Классы T r e e S e t и T r e eMap сохраняют элементы в отсортированном порядке.
Однако понятие "порядок сортировки" точно определяет применяемый ими ком­
паратор. По умолчанию эти классы сохраняют элементы , используя то, что в Java
называется естественным упорядичением, т.е. ожидаемым упорядочением, когда по­
сле А следует В, а после 1 - 2 и т.д. Если же элементы требуется упорядочить иным
образом, то при создании множества или отображения следует указать компара·
тор типа Comp a r a t o r . Это дает возможно точно управлять порядком сохранения
элементов в отсортированных коллекциях.
----------------------------------------------------------------------------------------------------------------------------------------
TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.Сложность выполнения основных операций
в TreeSet lg N.
-----------------------------------------------------------------------------------------------------------------------------------------
Устройство TreeSet?
TreeSet основан на красно-черном дереве.
-----------------------------------------------------------------------------------------------------------------------------------------
Что будет, если добавлять элементы в TreeSet по возрастанию?
Обычно данный вопрос собеседник предваряет фразой, что в основе TreeSet лежит бинарное дерево и если добавлять элементы
по возрастанию, то как они будут распределены по дереву.
Если нет точного представления об устройстве TreeSet, а есть общее понимание о том, что это бинарное дерево (в чем нас
дополнительно уверяет собеседник), то данный вопрос может привести к интересному результату: все элементы после доабвления
в обычное бинарное дерево будут находится в одной ветви длиной N элементов, что сводит на нет, все преимущества такой
структуры, как дерево (фактически получается список). На самом, деле, как выше упоминалось в основе TreeSet лежит
красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в
него элементы, преимущества этой структуры данных будут сохраняться.
------------------------------------------------------------------------------------------------------------------------------------------
Ввод элемента в древовидное множество происходит медленнее, чем в хеш-таблицу (табл. 9.3), но все же намного быстрее, чем
в требуемое место массива или связного списка. Если древовидное множество состоит из п элементов, то в среднем требуется
log2n сравнений, чтобы найти правильное расположение нового элемента. Так, если древовидное множество уже содержит 1000
элементов, для ввода нового элемент потребует около 10 сравнений.
------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Начиная с версии Java SE 6, класс TreeSet реализует интерфейс NavigableSet, в который введены удобные методы
для обнаружения элементов древовидного множества и его обхода в обратном порядке. Подробнее об этом см. в документации
на прикладной программный интерфейс API.
------------------------------------------------------------------------------------------------------------------------------------------
•
TreeSetO
•
TreeSet(Comparator^ super E> com parator)
Конструируют пустое древовидное множество.
•
TreeSet (Collection<? extends E> e l e m e n t s )
•
TreeSet(SortedSet<E> s )
Конструируют древовидное множество и вводят в него все элементы из коллекции.
------------------------------------------------------------------------------------------------------------------------------------------


*/
