package collections.list;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * This program demonstrates the ArrayList class.
 *
 * @author Cay Horstmann
 * @version 1.11 2012-01-26
 */
public class ExampleArrayList {
    public static void main(String[] args) {

//----------------------------------------------------------------------------------------------------------------------------------------
        List<String> values = new ArrayList<>();
        values.add("A");
        values.add("B");
        values.add("C");
        System.out.println(values);

        System.out.println();
        List<String> someValues = new ArrayList<>(values);
        System.out.println(someValues);

        System.out.println();
        List<String> someValues_222 = List.copyOf(values);
        System.out.println(someValues_222);

        values.add("33333");

        System.out.println();
        System.out.println(values);
        System.out.println(someValues);
        System.out.println(someValues_222);

        System.out.println();
        someValues_222.add("99999999");
        System.out.println(someValues_222);

//----------------------------------------------------------------------------------------------------------------------------------------
//        List<Integer> list = new ArrayList<>(Arrays.asList(1,1,1));
//        System.out.println(list.size());
//----------------------------------------------------------------------------------------------------------------------------------------
//        // Вы можете использовать конструктор ArrayList(capacity) и указать свою начальную емкость списка.
        ArrayList<Integer> arraylist = new ArrayList<>(Arrays.asList(234, 5, 1, 2, 3, 46, 7, 46, 3));
//        arraylist.forEach(obj -> System.out.print(obj + ", "));
//
//        System.out.println();
//        arraylist.add(99);
//        arraylist.forEach(obj -> System.out.print(obj + ", "));
//
//        /*Если заранее известно, сколько элементов требуется хранить в массиве, то перед
//            заполнением списочного массива достаточно вызвать метод ensureCapacity()*/
//        arraylist.ensureCapacity(20);
//
//        /*Метод size() возвращает фактическое количество элементов в списочном мас­сиве.*/
//        System.out.println("\n" + arraylist.size());  // mehod size vivodit kolichestvo elemento a ne obiom Lista
//
//        /*Если вы уверены, что списочный массив будет иметь постоянный размер, може­те вызвать метод trimToSize(),
//        который устанавливает размер блока памяти таким образом, чтобы он точно соответствовал коли честву хранимых
//        элементов. Система сборки "мусора" предотвращает неэффективное использование памяти, освобождая ее излишки.*/
//        arraylist.trimToSize();
//        /*Если добавить новые элементы в списочный массив после усечения его размера ме­тодом trimToSize(), блок памяти
//        будет перемещен, на что потребуется дополнитель­ное время. Поэтому вызывать данный метод следует лишь в том
//        случае, когда точно известно, что дополнительные элементы в списочный массив вводиться не будут.*/
//
//        System.out.println(arraylist.size());  // mehod size vivodit kolichestvo elemento a ne obiom Lista


//----------------------------------------------------------------------------------------------------------------------------------------
        List<Integer> arrayList1 = Arrays.asList(234, 5, 1, 2, 3, 46, 7, 46, 3);
//      arrayList1.add(3);
//      arrayList1.remove(0);
//        arrayList1.set(2, 5555);
//
//        List<Integer> arrayList3 = new ArrayList(Arrays.asList(234, 5, 1, 2, 3, 46, 7, 46, 3));
//        arrayList3.add(3);
//        arrayList3.remove(0);
//        arrayList3.size();
//
//        List<Integer> arrayList2 = Collections.nCopies(100, 0);
//        System.out.println(arrayList2);
//        System.out.println(arrayList2.size());

//----------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------

    }
}

/*
========================================================================================================================
 ArrayList — реализует интерфейс List. Как известно, в Java массивы имеют фиксированную длину, и после того как массив
 создан, он не может расти или уменьшаться. ArrayList может менять свой размер во время исполнения программы, при этом
 не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том
 числе и null.
========================================================================================================================
 ArrayList — как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая
 null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию
 следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за
 особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию
 рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции.
========================================================================================================================
 Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время (так как это массив),
 минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится так же за постоянное
 время. В среднем потому, что массив имеет определенный начальный размер n (в коде это параметр capacity), по умолчанию
 n = 10, при записи n+1 элемента, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы
 из старого массива + новый, добавляемый элемент. В итоге получаем, что при добавлении элемента при необходимости расширения
 массива, время добавления будет значительно больше, нежели при записи элемента в готовую пустую ячейку. Тем не менее, в
 среднем время вставки элемента в конец списка является постоянным. Удаление последнего элемента происходит за константное
 время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех
 элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не
 уменьшается, до явного вызова метода trimToSize().
========================================================================================================================
 Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов
 типа Object (с приведением к типу, разумеется).
========================================================================================================================
 Если места в массиве не достаточно, новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1.
 Второй момент это копирование элементов. Оно осуществляется с помощью native метода System.arraycopy(), который
 написан не на Java.
========================================================================================================================
 При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево и
 реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива
 существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().
========================================================================================================================
 Очень важно ещё и понимать что элементы ArrayList`а хранятся массивом, т.е. линейно в памяти, и можно довольно удачно
 загрузить кусок массива в кэш процессора, что очень круто скажется на производительности.
========================================================================================================================
 Добавление в «середину» списка!!!
 Добавление элемента на позицию с определенным индексом происходит в три этапа:
 1) проверяется, достаточно ли места в массиве для вставки нового элемента;
 2) подготавливается место для нового элемента с помощью System.arraycopy();
 3) перезаписывается значение у элемента с указанным индексом.
========================================================================================================================
 Как можно догадаться, в случаях, когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных
 мест, то вызов System.arraycopy() случится дважды: первый в ensureCapacity(), второй в самом методе add(index, value),
 что явно скажется на скорости всей операции добавления.
 В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать
 метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза, в итоге это
 будет гораздо быстрее поэлементного добавления.
========================================================================================================================
 Удаление элементов
 Удалять элементы можно двумя способами:
 — по индексу remove(index)
 — по значению remove(value)

 При удалении по значению, в цикле просматриваются все элементы списка, до тех пор пока не будет найдено соответствие.
 Удален будет лишь первый найденный элемент.

 При удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти.
 Поэтому не стоит пренебрегать методом trimToSize().
========================================================================================================================
 Итоги
 — Быстрый доступ к элементам по индексу за время O(1);
 — Доступ к элементам по значению за линейное время O(n);
 — Медленный, когда вставляются и удаляются элементы из «середины» списка;
 — Позволяет хранить любые значения в том числе и null;
 — Не синхронизирован.
========================================================================================================================
ВНИМАНИЕ! Не вызывайте метод list.set(i,х) до тех пор, пока размер списочного массива
больше i . Например, следующий код написан неверно:
    ArrayList<EmployeeRAF> list = new ArrayList<EmployeeRAF>(100);
    //емкость списочного массива равна 100, а его размер - 0
    list.set(0,х); // нулевого элемента в списочном массиве пока еще нет
Для заполнения списочного массива вызывайте метод add() вместо метода set(), а последний
применяйте только для замены ранее введенного элемента.
========================================================================================================================
ArrayList<T>()
    Конструирует пустой списочный массив.

ArrayList<T>(int initialCapacity)
    Конструирует пустой списочный массив заданной емкости.
    Параметры:
              initialCapacity Первоначальная емкость списочного массива

boolean add(T obj)
    Добавляет элемент в конец массива. Всегда возвращает логическое значение true.
    Параметры: obj Добавляемый элемент

int size ()
    Возвращает количество элементов, хранящихся в списочном массиве. (Количество элементов от­
    личается от емкости массива и не превосходит ее.)

void ensureCapacity(int capacity)
    Обеспечивает емкость списочного массива, достаточную для хранения заданного количества эле­
    ментов без изменения внутреннего массива, предназначенного для хранения данных в памяти.
    Параметры:
            capacity Требуемая емкость списочного массива

void trimToSize ()
    Сокращает емкость списочного массива до его текущего размера.
========================================================================================================================
♦ void set(int index, T obj)
    Устанавливает значение в элементе списочного массива по указанному индексу, заменяя преды-
    дущее его содержимое.
        Параметры: index obj
        Позиция (число от 0 до size () - 1| Новое значение

• Т get(int index)
    Извлекает значение, хранящееся в элементе списочного массива по указанному индексу.
        Параметры: index
        Индекс элемента, из которого извлекается
        значение (число от 0 до size () - 1)

•void add(int index, T obj)
    Сдвигает существующие элементы списочного массива для вставки нового элемента.
        Параметры: index obj
        Позиция вставляемого элемента (числоот0доsize() - 1) Новый элемент

•Т remove (int index)
    Удаляет указанный элемент и сдвигает следующие за ним элементы. Возвращает удаленный элемент.
       Параметры: index
       Позиция удаляемого элемента (числоот0доsize() - 1)
========================================================================================================================


* */
