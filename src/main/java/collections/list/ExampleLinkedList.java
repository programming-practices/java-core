package collections.list;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

/**
 * This program demonstrates operations on linked lists.
 *
 * @author Cay Horstmann
 * @version 1.11 2012-01-26
 */
public class ExampleLinkedList {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------------------------
        List<String> list1 = new LinkedList<>();
        list1.add("A_Amy");
        list1.add("A_Carl");
        list1.add("A_Erica");

        List<String> list2 = new LinkedList<>();
        list2.add("B_Bob");
        list2.add("B_Doug");
        list2.add("B_Frances");
        list2.add("B_Gloria");

        // merge the words from list2 into list1

        ListIterator<String> list1Iter = list1.listIterator();
        Iterator<String> list2Iter = list2.iterator();

        while (list2Iter.hasNext()) {
            if (list1Iter.hasNext()) list1Iter.next();
            list1Iter.add(list2Iter.next());
        }

        System.out.println(list1);

        // remove every second word from list2
        list2Iter = list2.iterator(); // treba skunytu iteraror v nachalo

        while (list2Iter.hasNext()) {
            list2Iter.next(); // skip one element

            if (list2Iter.hasNext()) {
                list2Iter.next(); // skip next element
                list2Iter.remove(); // remove that element
            }
        }

        System.out.println(list2);

        // bulk operation: remove all words in list2 from list1
        list1.removeAll(list2);

        System.out.println(list1);
//---------------------------------------------------------------------------------------------------------------------------------------
        /*for (int i = 0; i < list1.size (); i++)
          сделать что-нибудь с результатом вызова list1.get(i);
        Всякий раз, когда требуется обратиться к другому элементу с помощью метода get(), поиск начинается с самого начала
        списка. В объекте типа LinkedList не предпринимается никаких попыток буферизовать данные о расположении элементов
        в списке.*/
//---------------------------------------------------------------------------------------------------------------------------------------
        /*НА ЗАМЕТКУ! В методе get() предусмотрена единственная незначительная оптимизация: если указанный индекс больше
        величины size()/2, то поиск элемента начинается с конца списка.*/
//---------------------------------------------------------------------------------------------------------------------------------------
//        /*Для того чтобы добавить элемент на определенную позицию в списке,
//           необходимо вызвать метод add(index, value). Отличие от add(value) состоит в
//           определении элемента перед которым будет производиться вставка*/
//        List<Integer> linkedList = new LinkedList<>();
//        linkedList.add(0);
//        linkedList.add(1);
//        linkedList.add(2);
//
//        linkedList.add(2, 8);
//        System.out.println(linkedList);
//
//        /*Метод entry(index) пробегает по всему списку в поисках элемента с указанным индексом.
//           Направление обхода определяется условием (index < (size >> 1)). По факту получается что для
//           нахождения нужного элемента перебирается не больше половины списка, но с точки зрения
//           асимптотического анализа время на поиск растет линейно — O(n).
//
//           Как видно, разработчик может словить IndexOutOfBoundsException,
//           если указанный индекс окажется отрицательным или большим текущего значения size.
//           Это справедливо для всех методов где в параметрах фигурирует индекс.*/
//----------------------------------------------------------------------------------------------------------------------------------------

        /*Итераторы?
          Для собственноручного перебора элементов можно воспользоваться «встроенным» итератором.*/
//        List<String> linkedList1 = new LinkedList<>();
//        linkedList1.add("1");
//        linkedList1.add("2");
//        linkedList1.add("3");
//        linkedList1.add("4");
//        linkedList1.add("5");
//        ListIterator<String> listIterator = linkedList1.listIterator();
//        Iterator iterator = linkedList1.iterator();
//        while (iterator.hasNext()){
//            String next = (String)iterator.next();
//            System.out.print(next + ", ");
//            if (Integer.parseInt(next) == 3){
//                while (listIterator.hasNext()){
//                    System.out.print(listIterator.next());
//                }
//
//            }
//        }
        /* Приведенный выше код поместит указатель в начало списка. Так же можно начать перебор элементов с
           определенного места, для этого нужно передать индекс в метод listIterator(index).
           В случае, если необходимо начать обход с конца списка, можно воспользоваться методом descendingIterator().

           Стоит помнить, что ListIterator свалится с ConcurrentModificationException, если после создания итератора,
           список был изменен не через собственные методы итератора.
        */

//----------------------------------------------------------------------------------------------------------------------------------------
//
//----------------------------------------------------------------------------------------------------------------------------------------
//        // Create age linked list1.
//        LinkedList<String> linkedList2 = new LinkedList<String>();
//        // Add elements to the linked list1.
//        linkedList2.add("1");
//        linkedList2.add("2");
//        linkedList2.add("3");
//        linkedList2.add("4");
//        linkedList2.add("5");
//        linkedList2.addLast("Z");
//        linkedList2.addFirst("A");
//        linkedList2.add(1, "A2");
//        System.out.println("Original contents of ll: " + linkedList2);
//
//        // Remove elements from the linked list1.
//        linkedList2.remove("4");
//        linkedList2.remove(2);
//        System.out.println("Contents of ll after deletion: " + linkedList2);
//
//        // Remove first and last elements.
//        linkedList2.removeFirst();
//        linkedList2.removeLast();
//        System.out.println("ll after deleting first and last: " + linkedList2);
//
//        // Get and set age value.
//        String val = linkedList2.get(2);
//        linkedList2.set(2, val + " Changed");
//        System.out.println("ll after change: " + linkedList2);
//----------------------------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------------------------
    }

}

/*
------------------------------------------------------------------------------------------------------------------------
Этот класс расширяет класс AЬstractSequentalList и реализует интерфейсы List , Dequeu e и Queue . Он предостав.J,Iяет
структуру данных связного списка.
------------------------------------------------------------------------------------------------------------------------
 LinkedList — ещё одина реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной
 коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий
 и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное
 время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как
 стек или очередь. Для этого в ней реализованы соответсвующие методы.
------------------------------------------------------------------------------------------------------------------------
 LinkedList — реализует интерфейс List. Является представителем двунаправленного списка, где каждый элемент структуры
 содержит указатели на предыдущий и следующий элементы. Итератор поддерживает обход в обе стороны. Реализует методы
 получения, удаления и вставки в начало, середину и конец списка. Позволяет добавлять любые элементы в том числе и null.
------------------------------------------------------------------------------------------------------------------------
В интерфейсе итератора списка имеется также метод, предоставляющий индекс текущей позиции в списке. Но поскольку итераторы
в Java устроены таким образом, что обозначают позицию между элементами коллекции, то таких методов на самом деле два. Так,
метод nextlndex() возвращает целочисленный индекс того элемента, который должен быть возвращен при последующем вызове
метода next(). А метод previousIndex() возвращает индекс того элемента, который был бы возвращен при последующем вызове
метода previous (). И этот индекс будет, конечно, на единицу меньше, чем nextlndex. Оба метода действуют эффективно,
поскольку в итераторе запоминается текущая позиция.
------------------------------------------------------------------------------------------------------------------------
 LinkedList  за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и удаление, поиск
 позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за линейное время (но доступ
 к первому и последнему элементу списка всегда осуществляется за константное время — ссылки постоянно хранятся на первый
 и последний, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках
 последнего элемента). В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и
 по скорости выполнения операций. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление)
 с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.
------------------------------------------------------------------------------------------------------------------------
 Добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с
 помощью addFirst(value) выполняется за время O(1).
------------------------------------------------------------------------------------------------------------------------
 Внутри класса LinkedList существует static inner класс Entry, с помощью которого создаются новые элементы.
     Каждый раз при добавлении нового элемента, по сути выполняется два шага:
    1) создается новый экземпляр класса Entry
    2) переопределяются указатели на предыдущий и следующий элемент
------------------------------------------------------------------------------------------------------------------------
 Удаление элементов

 Удалять элементы из списка можно несколькими способами:
 — из начала или конца списка с помощью removeFirst(), removeLast() за время O(1);
 — по индексу remove(index) и по значению remove(value) за время O(n).

 Внутри метода remove(value) просматриваются все элементы списка в поисках нужного. Удален будет лишь первый найденный элемент.

 В общем, удаление из списка можно условно разбить на 3 шага:
    1) поиск первого элемента с соответствующим значением
    2) переопределяются указатели на предыдущий и следующий элемент
    3) удаление указателей на другие элементы и предание забвению самого элемента
------------------------------------------------------------------------------------------------------------------------
 Итоги
 — Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
 — На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n).
   Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(), потребуется O(1);
 — Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует соответствующие классы-оберки;
 — Не синхронизирован.
------------------------------------------------------------------------------------------------------------------------
Рекомендуется держаться подальше от всех методов, в которых целочисленный индекс служ ит для обозначения позиции в связном
списке. Если требуется произвольный доступ к коллекции, лучш е воспользоваться обычным или списочным массивом типа ArrayList,
а не связным списком.
------------------------------------------------------------------------------------------------------------------------
В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.
Списки обеспечивают быструю вставку и выполнение.
------------------------------------------------------------------------------------------------------------------------
•
LinkedListО
Конструирует пустой связный список.
•
LinkedList (Collection<? extends E > elements)
Конструирует связный список и вводит в него элементы из коллекции.
•
void addFirst(E element)
•
void addLast(E element)
Вводят элемент в начале или в конце списка.
•
Е getFirstO
•
Е getLastO
Возвращают элемент из начала или из конца списка.
•
Е removeFirstO
•
Е removeLast()
Удаляют и возвращают элемент из начала или из конца списка.
------------------------------------------------------------------------------------------------------------------------------------------
* */
