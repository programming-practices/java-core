package oop;

public class ExampleFloat {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------
//        Float f1 = new Float(Float.NaN);
//        Float f2 = new Float(Float.NaN);
//        System.out.println("(f1 == f2) = " + (f1 == f2) + "\nf1.equals(f2) = " + f1.equals(f2) + "\n(Float.NaN == Float.NaN) = " + (Float.NaN == Float.NaN));
//-------------------------------------------------------------------------------------------------------------------
//        Float f11 = +0.0f;
//        Float f21 = -0.0f;
//        System.out.println(f11 == f21);
//        System.out.println(f11.equals(f21));

//        Float f31 = new Float(+0.0f);
//        Float f41 = new Float(-0.0f);
//        System.out.println(f31 == f41);
//        System.out.println(f31.equals(f41));
//-------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------
        float fQ = 0.0f / 1.0f;
        float fS = 0.0f / -1.0f;
        System.out.println("fQ = " + fQ);
        System.out.println("fS = " + fS);
        System.out.println("fQ == fS: " + (fQ == fS));
        float f3A = 1.0f / fQ;
        float f4A = 1.0f / fS;
        System.out.println("f31A = " + f3A);
        System.out.println("f41A = " + f4A);

        /*В представлении вещественных чисел старший бит является знаковым. А что будет, если все остальные биты
        равны 0? В отличие от целых, где в такой ситуации получается отрицательное число, находящееся на нижней
        границе диапазона представления, вещественное число только со старшим битом, выставленным в 1, тоже
        обозначает 0, только со знаком минус. Таким образом, у нас есть два нуля – +0.0 и -0.0.

        Возникает логичный вопрос – считать ли эти числа равными? Виртуальная машина считает именно так. Однако,
        это два разных числа, ибо в результате операций с ними получаются разные значения (как видно на
        приведенном примере).

        Таким образом, в некоторых случаях есть смысл расценивать +0.0 и -0.0 как два разных числа. А если у нас есть
        два объекта, в одном из которых поле равно +0.0, а в другом -0.0 – эти объекты точно так же можно расценивать
        как неравные. Возникает вопрос – а как понять, что числа неравны, если их прямое сравнение виртуальной
        машиной дает true?
        Ответ таков. Несмотря на то, что виртуальнай машина считает эти числа равными, представления у них все-таки
        отличаются. Поэтому – единственное, что можно сделать, это сравнить представления. А для того, чтобы его
        получить, существуют методы int Float.floatToIntBits(float) и long Double.doubleToLongBits(double), которые
        возвращают битовое представление в виде int и long соответственно (продолжение предыдущего примера): */

        int i1 = Float.floatToIntBits(fQ);
        int i2 = Float.floatToIntBits(fS);
        System.out.println("i1 (+0.0):" + Integer.toBinaryString(i1));
        System.out.println("i2 (-0.0):" + Integer.toBinaryString(i2));
        System.out.println("i1==i2: " + (i1 == i2));

        /*Таким образом, если у вас +0.0 и -0.0 – разные числа, то сравнивать вещественные
        переменные следует через их битовое представление.*/
//---------------------------------------------------------------------------------------------------------------------

    }
}
