package oop;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Date;

/**
 * This program demonstrates the use of inner classes.
 *
 * @author Cay Horstmann
 * @version 1.11 2015-05-12
 */
public class ExampleInnerClass {
    public static void main(String[] args) {
        /*Так, если класс TimePrinter является открытым внутренним клас­сом, его объекты можно создать для любых
        "говорящих часов", как показано ниже.
                    TalkingClock jabberer = new TalkingClock(1000, true);
                    TalkingClock.TimePrinter listener = jabberer, new TimePrinter () ;
        Но если ссылка на внутренний класс делается за пределами области действия внешнего класса, то она указывается
        следующим образом:
                    ВнешнийКласс.ВнутреннийКлас с*/
        TalkingClockQ clock = new TalkingClockQ(1000, true);
        clock.start();

        // keep program running until user selects "Ok"
        JOptionPane.showMessageDialog(null, "Quit program?");
        System.exit(0);
    }
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClockQ {
    private int interval;
    private boolean beep;

    /**
     * Constructs a talking clock
     *
     * @param interval the interval between messages (in milliseconds)
     * @param beep     true if the clock should beep
     */
    public TalkingClockQ(int interval, boolean beep) {
        this.interval = interval;
        this.beep = beep;
    }

    /**
     * Starts the clock.
     */
    public void start() {
        /*С другой стороны, конструктор внутреннего класса можно записать более явным образом, используя следующий синтаксис:
                ОбъектВнешнегоКласса.new ВнутреннийКласс(параметры конструктора)
        Например, в приведенной ниже строке кода ссылка на внешний класс из вновьсозданного объекта типа TimePrinter
        получает ссылку this на метод, создающий объект внутреннего класса.
                ActionListener listener = this.new TimePrinter();
        Такой способ применяется чаще всего, хотя явное указание ссылки this здесь, как всегда, излишне. Тем не менее
        это позволяет явно указать другой объект в ссылке на объ­ект внешнего класса.*/
        ActionListener listener = new TimePrinter();
//        ActionListener listener = this.new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }

    /*НА ЗАМЕТКУ! Любые статические поля должны быть объявлены во внутреннем классе как конеч­ные (final) по следующей простой
    причине: несмотря на то, что предполагается получить одно­значный экземпляр статического поля, для каждого внешнего объекта
    имеется отдельный экзем ­пляр внутреннего класса. Если бы поле не было конечным, оно могло бы и не стать однозначным.*/
    public class TimePrinter implements ActionListener {
        /*Но оказывается, что внутренний класс имеет доступ не только к своим полям, но и к полям создавшего его объекта,
        т.е. эк­земпляра внешнего класса. Для того чтобы это стало возможным, внутренний класс должен содержать ссылку на
        объект внешнего класса.
        В определении внутреннего класса эта ссылка не присутствует явно. Чтобы проде­ монстрировать,
        каким образом она действует, введем в код ссылку outer. Тогда метод actionPerformed() будет выглядеть следующим образом:
                    public void actionPerformed(ActionEvent event){
                        Date now = new Date();
                        System.out.println("At the tone, the time is " + now);
                        if {outer.beep) Toolkit.getDefaultToolkit().beep();
                    }
        Еще раз обращаем ваше внимание на то, что слово outer не является ключевым в Java. Оно используется только для
        иллюстрации механизма, задействованного во внутренних классах.*/

        /*В предыдущем разделе ссылка на внешний класс была названа outer для того, чтобы стало понятнее, что это ссылка
        из внутреннего класса на внешний. На самом деле синтаксис для внешних ссылок немного сложнее. Так, приведенное
        ниже выра­жение обозначает внешнюю ссылку.
                ВнешнийКласс.this
        Например, во внутреннем классе TimePrinter можно создать метод actionPerformed() следующим образом:
                public void actionPerformed(ActionEvent event){
                    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
                }*/
        public void actionPerformed(ActionEvent event) {
            System.out.println("At the tone, the time is " + new Date());
//            if (beep) Toolkit.getDefaultToolkit().beep();
            if (TalkingClockQ.this.beep) Toolkit.getDefaultToolkit().beep();
        }

        /*У внутреннего класса не может быть статических методов. В спецификации на язык Java не пояс­няются причины
        для такого ограничения. Во внутреннем классе можно было бы разрешить лишьте статические методы, которые имели
        бы доступ только к статическим полям и методам из объем­лющего класса. Очевидно, что разработчики Java решили,
        что сложности внедрения такой возмож­ности перевешивают те преимущества, которые она может дать.*/
//        public static void aVoid(){}
    }
}

/*
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Любые статические поля должны быть объявлены во внутреннем классе как конеч­ные (final) по следующей простой
причине: несмотря на то, что предполагается получить одно­значный экземпляр статического поля, для каждого внешнего объекта
имеется отдельный экзем ­пляр внутреннего класса. Если бы поле не было конечным, оно могло бы и не стать однозначным.
У внутреннего класса не может быть статических методов. В спецификации на язык Java не пояс­няются причины для такого
ограничения. Во внутреннем классе можно было бы разрешить лишьте статические методы, которые имели бы доступ только к
статическим полям и методам из объем­лющего класса. Очевидно, что разработчики Java решили, что сложности внедрения такой
возмож­ности перевешивают те преимущества, которые она может дать.
----------------------------------------------------------------------------------------------------------------------
Внутренним называется один класс, определенный в другом классе. А зачем он вообще нужен? На то имеются следующие причины.
    • Объект внутреннего класса имеет доступ к данным объекта, в котором он опре­делен, включая закрытые данные.
    • Внутренний класс можно скрыть от других классов того же пакета.
    • Анонимный внутренний класс оказывается удобным в тех случаях, когда требу­ется определить обратный вызов в процессе
      выполнения программы, не при­бегая к необходимости писать много кода.
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Класс TimePrinter можно было бы объявить как закрытый (private). И тогда конструировать объекты типа TimePrinter
могли бы только методы из класса TalkingClock. Закрытыми могут быть только внутренние классы. А обычные классы всегда
доступны в пределах пакета или ж е полностью открыты.
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Если вы пользуетесь UNIX, не забудьте экранировать зна к $, указывая имя класса
в командной строке. Следовательно, запускайте программу ReflectionTest или утилиту javap
таким способом:
java refle ction .ReflectionTest ВнутреннийКласс.TalkingClock\$TimePrinter
или же таким:
javap -private ВнутреннийКласс.TalkingClock\$TimePrinter
----------------------------------------------------------------------------------------------------------------------
Внутренние классы оказываются полез­ными при разработке коллекций взаимосвязанных классов.
----------------------------------------------------------------------------------------------------------------------
Зачем же создатели языка Java пожертвовали преимуществами, которыми он вы­
годно отличался от других языков программирования, в пользу изящного и, безуслов­
но, интересного механ изма, выгода от которого, впрочем, сомнительна? Не пытаясь
дать исчерпывающий ответ на этот вопрос, заметим только, что обращение с вну­
тренними классами происходит на уровне компилятора, а не виртуальной машины.
Для их обозначения используется знак $, разделяющий имена внешних и внутренних
классов. Таким образом, для виртуальной машины внутренние классы неотличимы
от внешних.
Например, класс TimePrinter, входящий в состав класса TalkingClock, преобра­
зуется в файл TalkingClock$TimePrinter. class. Для того чтобы посмотреть, каким
образом действует этот механизм, попробуйте провести следующий эксперимент:
запустите на выполнение программу ReflectionTest (см. главу 5) и выполните реф­
лексию класса TalkingClock$TimePrinter. С другой стороны, можно воспользовать­
ся утилитой ja v a p следующим образом:
javap -private ИмяКласса
В итоге будет получен следующий результат:
        public class TalkingClock$TimePrinter{
            public TalkingClock$TimePrinter(TalkingClock);
            public void actionPerformed(java.a w t .event.ActionEvent);
            final TalkingClock this$0;
        }
----------------------------------------------------------------------------------------------------------------------
*/