package Examples.OOP;


import java.time.LocalDate;

/**
 * This program demonstrates inheritance.
 *
 * @author Cay Horstmann
 * @version 1.21 2004-02-21
 */
public class ExampleInherence {
    public static void main(String[] args) {
        // construct a Manager object
        Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);

        // допускается следующий вызов
        boss.setBonus(5000);

        Employee01[] staff = new Employee01[3];

        //В то же время приведенное ниже выражение составлено неверно.
        //staff[0].setBonus(5000); // ОШИБКА!

//        Manager manager = staff[0];  // ERROR

//        Manager manager = (Manager) staff[0]; // a tak net ERROR, no nado byt ostoroznum s prevedeniemi tipov

        // lydwe zdelat tak
//        if (staff[0] instanceof Manager){Manager manager1 = (Manager) staff[0];}

        // fill the staff array with Manager and EmployeeRAF objects

        staff[0] = boss;
        staff[1] = new Employee01("Harry Hacker", 50000, 1989, 10, 1);
        staff[2] = new Employee01("Tommy Tester", 40000, 1990, 3, 15);

        // print out information about all EmployeeRAF objects
        for (Employee01 e : staff)
            System.out.println("name=" + e.getName() + ",salary=" + e.getSalary());
    }
}


class Employee01 {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee01(String name, double salary, int year, int month, int day) {
        this.name = name;
        this.salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}


class Manager extends Employee01 {
    private double bonus;

    /*Вызов, содержащий обращение super, должен быть первым оператором в конструкторе подкласса.
    Если конструктор подкласса не вызывает явно ни одного из конструкторов супер­ класса, то из этого суперкласса
    автоматически вызывается конструктор без аргумен­тов. Если же в суперклассе отсугствует конструктор без ар1ументов,
    а конструктор подкласса не вызывает явно другой конструктор из суперкласса, то компилятор Java выдаст сообщение
    об ошибке.*/

    /**
     * @param name   the employee's name
     * @param salary the salary
     * @param year   the hire year
     * @param month  the hire month
     * @param day    the hire day
     */
    public Manager(String name, double salary, int year, int month, int day) {
        super(name, salary, year, month, day);
        bonus = 0;
    }

    /*Но оказывается, что такой способ не годится. Метод getSalaryO из класса Manager не имеет доступа к закрытым
    полям суперкласса. Иными словами, ме­тод getSalaryO из класса Manager не может непосредственно обратиться к полю
    salary, несмотря на то, что у каждого объекта типа Manager имеется поле с таким же именем.*/

//    public double getSalary(){
//        return salary + bonus; // не сработает!
//    }


    /*Дело в том, что метод getSalary () вызывает сам себя, поскольку в классе Manager имеется одноименный метод
    (именно его мы и пытаемся реализовать). В итоге возни­кает бесконечная цепочка вызовов одного и того же метода,
    что приводит к аварий­ному завершению программы.*/

//    public double getSalary() {
//        double baseSalary = getSalary(); // по-прежнему не сработает!
//        return baseSalary + bonus;
//    }

    public double getSalary() {
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }

    public void setBonus(double b) {
        bonus = b;
    }
}


/*
---------------------------------------------------------------------------------------------------------------------
В языке Java множественное наследование не поддерживается.
---------------------------------------------------------------------------------------------------------------------
Существует простое правило, позволяющее определить, стоит ли в конкретной
ситуации применять наследование или нет. Если между объектами существует от­
ношение "является", то каждый объект подкласса является объектом суперкласса.
---------------------------------------------------------------------------------------------------------------------
В завершение этой главы приведем некоторые рекомендации относительно надле­
жащего применения очень полезного механизма наследования.
1. Размещайте общие операции и поля в суперклассе.
Поле паше было перемещено в класс Person именно для, чтобы не повторять
его в классах EmployeeRAF и Student.
2. Старайтесь не пользоваться защищенными полями.
Некоторые разработчики полагают, что следует "н а всякий случай" объявлять
большинство полей защищенными, чтобы подклассы могли обращаться к ним
по мере надобности. Но имеются две веские причины, по которым такой меха­
низм не гарантирует достаточной защиты. Во-первых, множество подклассов нео­
граниченно. Всякий может создать подкласс, производный от данного класса, а за­
тем написать программу, получающую непосредственный доступ к защищенным
полям его экземпляра, нарушая инкапсуляцию. И во-вторых, в Java к защищен­
ным полям имеют доступ все классы, находящиеся в том же самом пакете, незави­
симо от того, являются ли они подклассами данного класса или нет. В то же время
полезно объявлять защищенными методы, которые не предназначены для общего
употребления и должны быть переопределены в подклассах.
3. Используйте наследование для моделирования отношений "является".
Наследование позволяет экономить время и труд при разработке программ, но
иногда им злоупотребляют. Допустим, требуется создать класс Contractor. У
работника, нанимаемого по контракту, имеется свое имя и дата заключения до­
говора, но у него нет оклада. У него почасовая оплата, причем он работает не
так давно, чтобы повышать оплату его труда. Ниже показано, как можно сделать
класс Contractor подклассом, производным от класса EmployeeRAF, добавив поле
hourlyWage.
class Contractor extends EmployeeRAF
{
private double hourlyWage;
}
Но это не совсем удачная идея. Ведь в этом случае получается, что каждый
работник, нанятый по контракту, имеет и о к ла л и почасовую оплату. Если вы
попробуете реализовать методы для распечатки платежных и налоговых ведо­
мостей, то сразу же проявится недостаток такого подхода. Программа, кото­
рую вам придется написать, будет гораздо длиннее той, которую вы могли бы
создать, не прибегая к неоправданному наследованию.
Отношение "контрактный работник-постоянный работник" не удовлетворяет
критерию "является". Работники, нанятые по контракту, не являются постоян­
ными и относятся к особой категории работников.
4. Не пользуйтесь наследованием, если не все методы имеет смысл сделать наследуе­
мыми.
Допустим, требуется создать класс Holiday. Разумеется, праздники — это раз­
новидность календарных дней, а дни можно представить в виде объектов типа
GregorianCalendar, поэтому наследование можно применить следующим об­
разом:
class Holiday extends GregorianCalendar(...)
К сожалению, множество праздников оказывается незамкнутым при наследо­
вании. Среди откры тых методов из класса GregorianCalendar имеется метод
add ( ) , который может превратить праздничные дни в будничные следующим
образом:
Holiday Christmas;
Christmas.add(Calendar.DAY_OF_MONTH, 12);
Следовательно, наследование в данном случае не подходит. Следует, однако,
иметь в виду, что подобные затруднения не возникают, если используется класс
Local Date. Этот класс является неизменяемым, и поэтому в нем отсутствует
метод, способный превратить праздничный день в будничный.
5. Переопределяя метод, не изменяйте его предполагаемое поведение.
Принцип подстановки распространяется не только на синтаксис, но и на пове­
дение, что важнее. При переопределении метода не следует без особых на то
причин изменять его поведение. В этом компилятор вам не поможет. Ведь он
не в состоянии проверить, оправдано ли переопределение метода. Допустим,
требуется устранить упомянутый выше недостаток метода add () из класса
Holiday, переопределив этот метод таким образом, чтобы он, например, не
выполнял никаких действий или же возвращал следующий праздничный день.
Но такое переопределение нарушает принцип подстановки. При выполнении
приведенной ниже последовательности операторов пользователь вправе ожи­
дать вполне определенного поведения и соответствующего результата, независи­
мо от того, является ли объект х экземпляром класса GregorianCalendar или
Holiday.
int dl = х .get(Calendar.DAY_OF_MONTH);
x.add(Calendar.DAY_OF_MONTH, 1);
int d2 = x.get(Calendar.DAY_OF_MONTH);
System.out.println(d2 - dl);
Безусловно, такой поход содержит камень преткновения. Разные пользовате­
ли посчитают естественным различное поведение программы. Так, по мнению
некоторых, принцип подстановки требует, чтобы в методе Manager.equals ()
не учитывалась премия в поле bonus, поскольку она игнорируется в методе
EmployeeRAF. equals () . Подобные споры могут длиться бесконечно и не дать ни­
какого результата. Поэтому, принимая конкретное решение, следует руковод­
ствоваться теми целями, для которых создается программа.
6. Пользуйтесь принципом полиморфизма, а не данными о типе.
Вспомните о принципе полиморфизма, как только увидите код, имеющий сле­
дующий вид:
if (х типа 1)
действие1(х );
else if (х типа 2)
действие2(х);
Имеют ли действие_1 и действие_2 общий характер? Если имеют, то поме­
стите соответствующие методы в общий суперкласс или интерфейс обоих ти­
пов. Тогда можно просто сделать приведенный ниже вызов и выполнить пра­
вильное действие с помощью механизма динамического связывания, присуще­
го полиморфизму.
х .действие();
Код, в котором применяется принцип полиморфизма или реализован интер­
фейс, намного легче сопровождать и расширять, чем код, изобилующий про­
верками типов.
7. Не злоупотребляйте механизмом рефлексии.
Механизм рефлексии позволяет создавать программы с высоким уровнем
абстракции, где поля и методы определяются во время выполнения. Такая
возможность чрезвычайно полезна для системного программирования, но
для прикладного — практически не нужна. Рефлексия — очень хрупкий ме­
ханизм, поскольку компилятор не может помочь в обнаружении ошибок. Все
ошибки проявляются во время выполнения программы и приводят к возник­
новению исключений.
---------------------------------------------------------------------------------------------------------------------
*/