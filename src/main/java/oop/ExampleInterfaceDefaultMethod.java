package Examples.OOP;

//---------------------------------------------------------------------------------------------------------------------
interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

/*Что, если один и тот же метод сначала определен по умолчанию в одном интер­фейсе, а затем таким же образом в другом
интерфейсе или как метод в суперклассе? В таких языках, как Scala и C++, действуют сложные правила разрешения подобных
неоднозначностей. А в Java подобные правила оказываются намного более простыми и заключаются в следующем.
    1. В конфликте верх одерживает суперкласс. Если суперкласс предоставляет кон­кретный метод, то методы по умолчанию
    с одинаковыми именами и типами параметров просто игнорируются.
    2. Интерфейсы вступают в конфликт. Если суперинтерфейс предоставляет метод, а другой интерфейс — метод (по умолчанию
    или иначе) с таким же самым именем и типами параметров, то для разрешения конфликта необходимо пе­реопределить этот метод.

Рассмотрим второе правило. Допустим, в другом интерфейсе определен метод
sqrt() следующим образом:
*/
interface Modem {
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

interface NamedE {
    default void getName() {
        System.out.println("er");
    }
}

//---------------------------------------------------------------------------------------------------------------------
interface MyIF {
    // This is age "normal" interface method declaration.
    // It does NOT define age default implementation.
    int getNumber();

    // This is age default method. Notice that it provides
    // age default implementation.
    default String getString() {
        return "Default String";
    }
}

public class ExampleInterfaceDefaultMethod {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------
//        Formula formula1 = new Formula() {
//            @Override
//            public double calculate(int a) { return sqrt(a * 100); }
//        };
//
//        System.out.println(formula1.calculate(100));     // 100.0
//        System.out.println(formula1.sqrt(16));                // 4.0
//
//
//        Formula formula = new Formula() {
//            @Override
//            public double calculate(int a) { return 0; }
//
//            @Override
//            public double sqrt(int a) { return 0; }
//        };
//---------------------------------------------------------------------------------------------------------------------
        ClassExample classE = new ClassExample();
        double calculate = classE.calculate(4);
        System.out.println(calculate);

        /*Но допустим, что этот класс не перекомпилируется и просто используется содержа­щий его старый архивный JAR-файл.
        Этот класс по-прежнему загружается, несмотря на отсутствующий в нем метод. В программах могут по-прежнему
        строиться экземпля­ры класса Bag, и ничего плохого не произойдет. (Внедрение метода в интерфейс совме­стимо на
        уровне двоичного кода.) Но если в программе делается вызов метода stream() для экземпляра класса Bag, то
        возникает ошибка типа AbstractMethodError. Подобные затруднения можно устранить, если объявить метод stream()
        как default. И тогда класс Bag будет компилироваться снова. А если этот класс загружа­ется без перекомпиляции и
        метод stream () вызывается для экземпляра класса Bag, то такой вызов происходит по ссылке Collection, stream.*/
        double sqrt = classE.sqrt(4);
        System.out.println(sqrt);

//---------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------

    }

}

class ClassT implements Formula, Modem {
    /*Этот класс наследует оба конфликтующих метода sqrt(), предоставляемых интерфейсами Formula и Modem. В место того
    чтобы выбрать один из этих методов, компилятор Java выдаст сообщение об ошибке, предоставив программисту самому
    разрешать возникшую неоднозначность. Для этого достаточно предоставить метод sqrt() в классе Student и выбрать в нем
    один из конфликтующих методов сле­дующим образом:*/
    public double sqrt(int a) {
        return Formula.super.sqrt(a);
    }

    /*А теперь допустим, что в интерфейсе Modem не предоставляется реализация мето­да sqrt() по умолчанию, как показано ниже.
                        interface Modem{
                            String getName();
                        }
    Может ли класс ClassT унаследовать метод по умолчанию из интерфейса Formula? На первый взгляд это может показаться
    вполне обоснованным, но разработ­чики Java решили сделать выбор в пользу единообразия. Независимо от характера
    конфликта между двумя интерфейсами, хотя бы в одном из них предоставляется ре­ализация искомого метода, а компилятор
    выдаст сообщение об ошибке, предоставив программисту возможность самому разрешать возникшую неоднозначность.*/

    @Override
    public double calculate(int a) {
        return 0;
    }
}

//---------------------------------------------------------------------------------------------------------------------
class PersonE {
    public void getName() {
        System.out.println("Hola");
    }
}

/*Итак, мы рассмотрели конфликты между интерфейсами. А теперь рассмотрим класс, расширяющий суперкласс и реализующий
интерфейс, наследуя от обоих один и тот же метод. Допустим, класс Student, наследующий от класса Person и реализу­ющий
интерфейс Named, определяется следующим образом:
        class Student extends Person implements Named { . . . }
В таком случае значение имеет только метод из суперкласса, а любой метод по умолчанию из интерфейса просто игнорируется.
В данном примере класс Student наследует метод getName() из класса Person, и для него совершенно не важно, пре­доставляет
ли интерфейс Named такой же самый метод по умолчанию. Ведь в этом случае соблюдается первое упомянутое выше правило,
согласно которому в конфлик­те верх одерживает суперкласс.

Это правило гарантирует совместимость с версией Java SE 7. Если ввести методы по умолчанию в интерфейс, это никак не
скажется на работоспособности прикладно­го кода, написанного до появления методов по умолчанию в интерфейсах.

ВНИМАНИЕ! Метод по умолчанию, переопределяющий один из методов в классе Object, создать нельзя. Например, в интерфейсе
нельзя определить метод по умолчанию для метода toStri ngO или equals(), даже если это и покажется привлекательным для
таких интерфейсов, как List. Как следствие из правила, когда в конфликте верх одерживает суперкласс, такой метод вообще не
смог бы одолеть метод Object.toString() или Objects.equals ().
*/
//---------------------------------------------------------------------------------------------------------------------

class StudentE extends PersonE implements NamedE {

}

class ClassExample implements Formula {

    @Override
    public double calculate(int a) {
        return 0;
    }
}

// Implement MyIF.
class MyIFImp implements MyIF {
    // Only getNumber() defined by MyIF needs to be implemented.
    // getString() can be allowed to default.
    @Override
    public int getNumber() {
        return 100;

    }

}
//---------------------------------------------------------------------------------------------------------------------

/*
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! В прикладном программном интерфейсе Java API можно обнаружить целый ряд и н­терфейсов с сопровождающими
классами, реализующими все или некоторые их методы, как, на­пример, пары Collection/AbstractCollection и
MduseListener/MouseAdapter. Но, на­чиная с версии Java SE 8, такой подход считается устаревшим, поскольку достаточно
реализовать нужные методы в интерфейсе.
----------------------------------------------------------------------------------------------------------------------
Методы по умолчанию играют важную роль в дальнейшем развитии интерфейсов.
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Если ни один из интерфейсов не предоставляет реализацию по умолчанию общего
для них метода, то никакого конфликта не возникает. В таком случае для класса, реализующего эти
интерфейсы, имеются два варианта выбора: реализовать метод или оставить его нереализованным
и объявить класс как abstract.
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Если ни один из интерфейсов не предоставляет реализацию по умолчанию общего
для них метода, то никакого конфликта не возникает. В таком случае для класса, реализующего эти
интерфейсы, имеются два варианта выбора: реализовать метод или оставить его нереализованным
и объявить класс как abstract.
----------------------------------------------------------------------------------------------------------------------
*/
