package reflection_api;

import java.lang.reflect.Field;
import java.time.LocalDate;

public class ExampleReflection {
    public static void main(String[] args) {
        //--------------------------------------------------------------------------------------------------------------------
////        // Получение объекта типа Class
//        MyClass myClass = new MyClass();
//        Class classMyClass00 = myClass.getClass();
//        Class<MyClass> classMyclass01 = myClass.getClass(); // ERROR
//        Class<?> classMyClass02 = myClass.getClass(); // a tak nety error
//
////        Class<MyClass> classMyClass04 = "MyClass".getClass(); // ERROR
//        Class<?> classMyClass05 = "MyClass".getClass(); // nety ERROR
//
//        Class<MyClass> classMyClass03 = MyClass.class;
////        Class<MyClass> classMyClass06 = Class.forName("MyClass"); // Error
//        try {
//            // tak bydet error potomu chto nado ykazat celui pyt k kalssy
////            Class classMyClass07 = Class.forName("MyClass");
//            // a tak vso bydet xorowo
//            Class classMyClass06 = Class.forName("Examples.reflection_api.MyClass"); // nety Error
//        } catch (ClassNotFoundException e) {
//            e.printStackTrace();
//        }
//--------------------------------------------------------------------------------------------------------------------
//        // Получение имени класса
//        MyClass myClass = new MyClass();
//        Class class00 = myClass.getClass();
//        String nameMyClass = class00.getName();
//        System.out.println("Name for myClass is: " + nameMyClass);
//--------------------------------------------------------------------------------------------------------------------
//        // Нахождение суперклассов
//        MyClass myClass = new MyClass();
//        Class class01 = myClass.getClass();
//        Class superClass = class01.getSuperclass();
//        System.out.println("Super Class MyClass: " + superClass);
//--------------------------------------------------------------------------------------------------------------------
//        //Определение интерфейсов, реализуемых классом
//        MyClass myClass = new MyClass();
//        Class class02 = myClass.getClass();
//        Class[] interfaces = class02.getInterfaces();
//        System.out.print("Interfaces de Class is: ");
//        for (Class i : interfaces) {
////            System.out.print(i + ", ");  // nemnoho dryhoi vuvod
//            System.out.print(i.getName() + ", ");
//        }
//--------------------------------------------------------------------------------------------------------------------
        MyClassForTests harry = new MyClassForTests("Harry Hacker", 35000, 10, 1, 1989);
        // объект типа Class, представляющий класс MyClassForTests
        Class cl = harry.getClass();

        Field fName = null;
        Field fSalary = null;
        Field fHireDay = null;
        try {
            fName = cl.getDeclaredField("name");
            fSalary = cl.getDeclaredField("salary");
            fHireDay = cl.getDeclaredField("hireDay");
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }

        // поле name из класса MyClassForTests
        try {

            /*По умолчанию в механизме рефлексии соблюдаются правила доступа, установлен­
            ные в Java. Но если программа не контролируется диспетчером защиты, то эти пра­
            вила можно обойти. Чтобы сделать это, достаточно вызвать метод setAccessible ()
            для объектов типа Field, Method или Constructor, например, следующим образом:*/
            fName.setAccessible(true); // теперь можно сделать вызов fName.get(harry);
            fSalary.setAccessible(true); // теперь можно сделать вызов fSalary.get(harry);
            fHireDay.setAccessible(true); // теперь можно сделать вызов fHireDay.get(harry);

            /*Метод setAccessible() относится к классу AccessibleObject, являющемуся об­щим суперклассом для классов
            Field, Method и Constructor. Он нужен для обеспе­чения нормальной работы отладчиков, поддержки постоянных
            хранилищ и выпол­нения других подобных функций.*/

            /*На первый взгляд, в приведенном выше фрагменте кода нет ничего каверзного, но его выполнение приводит к
            ошибке. В частности, поле паше объявлено как private, а следовательно, метод get() сгенерирует исключение
            IllegalAccessException.Ведь метод get() можно применять только к открытым полям. Механизм безопас­ности Java
            позволяет определить, какие именно поля содержит объект, но не дает возможности прочитать их содержимое,
            если эти поля недоступны.*/
            Object oName = fName.get(harry);
            System.out.println(oName.toString());

            /*С методом get () связано еще одно затруднение. Поле паше относится к типу String, а следовательно, его
            значение можно возвратить в виде объекта типа Object. Но допустим, что требуется определить значение поля
            salary. Оно относится к типу double, а в Java числовые типы не являются объектами. Чтобы разрешить это затруд­
            нение, можно воспользоваться методом getDouble () из класса Field или же мето­дом get(). Используя механизм
            рефлексии, любой из этих методов автоматически заклю чит поле в оболочку соответствующего класса, в данном
            случае — Double.*/
            Object oSalary = fSalary.get(harry);
//            Double oSalary = fSalary.getDouble(harry);
            System.out.println(oSalary.toString());

            Object oHireDay = fHireDay.get(harry);
            System.out.println(oHireDay.toString());

            System.out.println("------SetValues------");
            /*Разумеется, значение поля можно не только определять, но и задавать. Так, при вызове fArgInt.set(obj, value) в
            объекте obj задается новое значение value поля, пред­ставленного переменной fArgInt.*/

            fName.set(harry, "Piter Pen");
            fSalary.set(harry, new Double(55000));
            fHireDay.set(harry, LocalDate.of(1988, 06, 26));

            Object oName1 = fName.get(harry);
            System.out.println(oName1.toString());
            Object oSalary1 = fSalary.get(harry);
//            Double oSalary1 = fSalary.getDouble(harry);
            System.out.println(oSalary1.toString());
            Object oHireDay1 = fHireDay.get(harry);
            System.out.println(oHireDay1.toString());

        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        // значение в поле name объекта harry, т.е. объект типа String,
        // содержащий символьную строку "Harry Hacker"
//--------------------------------------------------------------------------------------------------------------------
    }
}




/*
----------------------------------------------------------------------------------------------------------------------
Программа, способная анализировать возможности классов, называется рефлек­тивной. Рефлексия — очень мощный механизм,
который можно применять для ре­шения перечисленных ниже задач.
    • Анализ возможностей классов в процессе выполнения программы.
    • Проверка объектов при выполнении программы; например, с помощью рефлек­сии можно реализовать метод toString(),
      совместимый со всеми классами.
    • Реализация обобщенного кода для работы с массивами.
    • Применение объектов типа Method, которые работают аналогично указателям на функции в языках, подобных C++.

Рефлексия — не только эффективный, но и сложный механизм. Ею интересуют­ся в основном разработчики инструментальных
средств, тогда как программисты, пишущие обычные прикладные программы, зачастую ею не пользуются.
----------------------------------------------------------------------------------------------------------------------
Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время
её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. Можно
также выполнять операции над полями и методами которые исследуются. Рефлексия в Java осуществляется с помощью
Java Reflection API. Этот интерфейс API состоит из классов пакетов java.lang и java.lang.reflect. С помощью
 интерфейса Java Reflection API можно делать следующее:

    1.Определить класс объекта.
    2.Получить информацию о модификаторах класса, полях, методах, конструкторах и суперклассах.
    3.Выяснить, какие константы и методы принадлежат интерфейсу.
    4.Создать экземпляр класса, имя которого неизвестно до момента выполнения программы.
    5.Получить и установить значение свойства объекта.
    6.Вызвать метод объекта.
    7.Создать новый массив, размер и тип компонентов которого неизвестны до момента выполнения программ.
    ...
----------------------------------------------------------------------------------------------------------------------
СОВЕТ. При запуске программы на выполнение сначала загружается класс, содержащий метод main ( ) .
Он загружает все необходимые классы. Каждый из классов, в свою очередь, загружает необходимые
ему классы и т.д. Если приложение достаточно крупное, этот процесс может отнять немало времени,
и пользователю придется ожидать окончания загрузки. Чтобы вызвать у пользователя иллюзию бы­
строго запуска, можно воспользоваться следующим приемом. Убедитесь в том, что класс, содержащий
метод main (), не обращается явно к другим классам. Отобразите в этом классе начальный экран при­
ложения. Затем приступайте к загрузке остальных классов, вызывая метод Class .forName ().
----------------------------------------------------------------------------------------------------------------------
НА ЗАМЕТКУ! Начиная с версии Java SE 5.0, класс Class является параметризованным. Напри­
мер, ссылка EmployeeRAF.class соответствует типу Class<EmployeeRAF>. Не будем пока что обсуж­
дать этот вопрос, чтобы не усложнять и без того довольно абстрактные понятия. На практике мож­
но вообще игнорировать параметр типа и пользоваться обычным вариантом класса Class.
----------------------------------------------------------------------------------------------------------------------
ВНИМАНИЕ! Исторически сложилось так, что метод get Na m e O возвращает для массивов не со­
всем обычные имена их типов, как показано ниже.
        •При вызове Doublet] .class.getName() возвращается символьная строка "[Ljava.lang. Double
        •При вызове int[] .class.getNameO возвращается символьная строка " [ I " .
----------------------------------------------------------------------------------------------------------------------

*/