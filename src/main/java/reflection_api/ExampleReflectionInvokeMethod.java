package Examples.Reflection_API;

import java.lang.reflect.Method;

/**
 * This program shows how to invoke methods through reflection.
 *
 * @author Cay Horstmann
 * @version 1.2 2012-05-04
 */
public class ExampleReflectionInvokeMethod {
    public static void main(String[] args) throws Exception {
        // get method pointers to the square and sqrt methods
        Method square = ExampleReflectionInvokeMethod.class.getMethod("square", double.class);
        Method sqrt = Math.class.getMethod("sqrt", double.class);

        // print tables of x- and y-values

        printTable(1, 10, 10, square);
        printTable(1, 10, 10, sqrt);
    }

    /**
     * Returns the square of a number
     *
     * @param x a number
     * @return x squared
     */
    public static double square(double x) {
        return x * x;
    }

    /**
     * Prints a table with x- and y-values for a method
     *
     * @param from the lower bound for the x-values
     * @param to   the upper bound for the x-values
     * @param n    the number of rows in the table
     * @param f    a method with a double parameter and double return value
     */
    public static void printTable(double from, double to, int n, Method f) {
        // print out the method as table header
        System.out.println(f);

        double dx = (to - from) / (n - 1);

        for (double x = from; x <= to; x += dx) {
            try {
                double y = (Double) f.invoke(null, x);
                System.out.printf("%10.4f | %10.4f%n", x, y);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}


/*
----------------------------------------------------------------------------------------------------------------------
public Object invoke (Object inplicitParameter, Object [] explici tParameters)
    Вызывает метод, описанный в объекте, передавая ему заданные параметры и возвращая значе­
    ние, вычисленное этим методом. Для статических методов в качестве неявного параметра пере­
    дается пустое значение n u l l . Примитивные типы следует передавать только в виде объектных
    оболочек классов. Возвращаемые значения примитивных типов должны извлекаться из объектных
    оболочек путем автораспаковки.
----------------------------------------------------------------------------------------------------------------------
    Аналогично класс Method содержит метод invoke () , позволяющий вызвать метод, заключенный в оболочку текущего
    объекта этого класса, следующим образом:
                Object invoke(Object obj, Object... args)
    Первый параметр этого метода является неявным, а остальные объекты представ­ляют собой явные параметры. Если метод
    статический, то первый параметр игнори­руется, а вместо него можно указать пустое значение null. Так, если объект ml
    пред­ставляет метод getName() из класса EmployeeRAF, то можно сделать следующий вызов:
                String n = (String) m l .invoke(harry);
    Если возвращаемый тип оказывается примитивным, метод invoke () возвратит вме­сто него тип объекта-оболочки. Допустим,
     объект m2 представляет метод getSal ary() из класса EmployeeRAF. В таком случае возвращаемый объект-оболочка фактически
     от­ носится к типу Double, и поэтому его необходимо привести к примитивному типу double. Это нетрудно сделать с
     помощью автораспаковки следующим образом:
                double s = (Double) m2.invoke(harry);
    Как же получить объект типа Method? Можно, конечно, вызвать метод getDeclaredMethods() и найти искомый объект среди
    возвращаемого массива объектов типа Method. Кроме того, можно вызвать метод getMethod () из класса Class. Его действие
    можно сравнить с методом getFieldO, получающим символьную строку с именем поля и возвращающим объект типа Field. Но
    методов с одним и тем же именем может быть несколько, и среди них приходится тщательно выбирать нужный метод.Именно
    по этой причине необходимо также предусмотреть массив, содержащий типы параметров искомого метода. Сигнатура метода
    getMethod() выглядит следу­ющим образом:
                Method getMethod(String имя, Class... типыПараметров)
    В качестве примера ниже показано, каким образом получаются указатели на ме­тоды getName() и raiseSalary() из класса EmployeeRAF.
                Method ml = EmployeeRAF.class.getMethod("getName");
                Method m2 = EmployeeRAF.class.getMethod("raiseSalary", double.class);
    Итак, выяснив правила применения объектов типа Method, продемонстрируем их употребление непосредственно в коде. В
    листинге 5.17 приведена программа, выво­дящая таблицу значений математической функции вроде Math.sqrt () или Math.sin()
    Разумеется, код, осуществляющий вывод таблицы на экран, не зависит от кон­кретной функции:
                doubledx=(to-from)/(n-1);
                for(doublex=from;x<=to;x+=dx){
                    double у = (Double) fArgInt .invoke(null, x ) ;
                    System.out.printf("%10.4f I %10.4f%n", x, y);
                }
    где fArgInt — это объект типа Method. А поскольку вызывается статический метод, то в ка­честве первого параметра методу
    invoke() передается пустое значение null. Для вывода таблицы со значениями математической функции Math, sqrt служит
    следу­ющая строка кода:
                Math.class.getMethod("sqrt", double.class)
    При вызове метода getMethod() ему передается имя метода sqrt() из класса Math и параметр типа double. В листинге
    5.17 приведен весь исходный код обобщен­ного варианта программы табличного вывода значений функции.

    Таким образом, с помощью объектов типа Method можно делать то же, что и с по­мощью указателей на функции в С (или
    делегатов в С#). Как и в С, такой стиль про­граммирования обычно неудобен и часто приводит к ошибкам. Что, если, например,
    вызвать метод invoke() с неверно заданными параметрами? В этом случае метод invoke() сгенерирует исключение.Кроме
    того, параметры метода invoke () и возвращаемое им значение обязательно должны быть типа Object. А это влечет за
    собой приведение типов в соответствующих местах кода. В итоге компилятор будет лишен возможности тщательно проверить ис­
    ходный код программы. Следовательно, ошибки в ней проявятся только на стадии те­стирования, когда исправить их будет
    намного труднее. Более того, программа, исполь­зующая механизм рефлексии для получения указателей на методы, работает
    заметно медленнее, чем программа, непосредственно вызывающая эти методы. По этим причинам пользоваться объектами
    типа Method рекомендуется толь­ко в самом крайнем случае. Намного лучше применять интерфейсы и внутренние классы,
    рассматриваемые в следующей главе. В частности, следуя указаниям разра­ботчиков Java, объекты типа Method не
    рекомендуется применять для организации функций обратного вызова, поскольку для этой цели вполне подходят интерфейсы,
    позволяющие создавать программы, которые работают намного быстрее и надежнее.*
----------------------------------------------------------------------------------------------------------------------
*/