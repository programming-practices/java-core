package exceptions;

public class ExampleException {
    public static void main(String[] args) {
//----------------------------------------------------------------------------------------------------------------------
        System.out.print("a");
        try {
            System.out.print("b");
            throw new IllegalArgumentException();
        } catch (RuntimeException e) {
            System.out.print("c");
        } finally {
            System.out.print("d");
        }
        System.out.print("e");

//----------------------------------------------------------------------------------------------------------------------
//        System.err.println("main() >>");
//        try{
//            method1();
//        }catch(RuntimeException e){
//            System.err.println("Bed......");
//        }
//        System.err.println("main() <<");
//----------------------------------------------------------------------------------------------------------------------
    }

    public static void method1() {
        System.err.println("method1()>>");
        method2();
        System.err.println("method1()<<");
    }

    public static void method2() {
        System.err.println("   method2()>>");
        method3();
        System.err.println("   method2()<<");
    }

    public static void method3() {
        System.err.println("      method3()>>");
//        if(true)return;
        if (true) throw new RuntimeException();
        System.err.println("      method3()<<");
    }


}

/*
----------------------------------------------------------------------------------------------------------------------
•Exception (Throwable cause) 1.4
•Exception(String message, Throwable cause)
        Создают объект типа Exception по заданному объекту cause.
----------------------------------------------------------------------------------------------------------------------
Рекомендации по обработке исключений
Специалисты придерживаются разных мнений относительно обработки исключе­
ний. Одни считают, что проверяемые исключения — это не более чем досадная поме­
ха, а другие готовы затратить дополнительное время и труд на их обработку. На наш
взгляд, исключения (особенно проверяемые) — полезный механизм, но, применяя
его, не стоит слишком увлекаться. В этом разделе дается ряд рекомендаций относи­
тельно применения и обработки исключений в прикладных программах.
1. Обработка исключений не может заменить собой простую проверку.
Д ля иллюстрации этого положения ниже приведен фрагмент кода, в котором
используется встроенный класс Stack. В этом коде делается 10 миллионов по­
пыток извлечь элемент из пустого стека. Сначала в нем выясняется, пуст ли стек:
if (!s.empty)) s.popO;
Затем элемент принудительно извлекается из стека, независимо от того, пуст ли
он или заполнен, как показано ниже. После этого перехватывается исключение
типа EmptyStackException, которое предупреждает, что так делать нельзя.
try ()
{
s.pop();
}
catch (EmptyStackException е)
{
}
Время, затраченное на тестовом компьютере для вызова метода
isE mptyO, составило 646 миллисекунд, а на перехват исключения типа
EmptyStackException — 21739 миллисекунд.
Как видите, перехват исключения занял намного больше времени, чем простая
проверка. Из этого следует вывод: пользуйтесь исклю чениями только в тех слу­
чаях, когда это оправданно, что зачастую бывает лишь в исключительных си­
туациях.
2. Не доводите обработку исключений до абсурдных мелочей.
Многие программисты заключают едва ли не каждый оператор в отдельный
блок try. Ниже показано, к чему приводит подобная мелочность при про­
граммировании на Java.
PrintStream out;
Stack s;
for(i=0;i<100;i++)
{
try
{
n = s .pop();
}
catch (EmptyStackException e)
{
// стек оказался пустым
}
try
{
out.writelnt(n);
}
catch (IOException e)
{
// сбой при записи данных в файл
При таком подходе объем кода значительно увеличивается. Поэтому хоро­
шенько подумайте о той задаче, которую должна решать ваша программа.
В данном случае требуется извлечь из стека 100 чисел и записать их в файл.
(Неважно, зачем это нужно, — это всего лиш ь пример.) Одно только генери­
рование исключения не является выходом из положения. Ведь если стек пуст,
то он не заполнится как по мановению волшебной палочки. А если при за­
писи числовых данных в файл возникает ошибка, то она не исчезнет сама со­
бой. Следовательно, имеет смысл разместить в блоке try весь фрагмент кода
для решения поставленной задачи, как показано ниже. Если хотя бы одна из
операций в этом блоке даст сбой, можно отказаться от решения всей задачи,
а не отдельных ее частей.
try
{
for (i=0;i<100;i++)
{
n = s .pop();
out.writelnt(n);
}
}
catch (IOException e)
{
// сбой при записи данных в файл
}
catch (EmptyStackException е)
{
// стек оказался пустым
}
Этот фрагмент кода уже выглядит намного яснее. Он выполняет одно из своих
основных назначений — отделяет нормальную обработку данных от обработки
исключений.
3. Правильно пользуйтесь возможностями, которые предоставляет иерархия наследо­
вания исключений.
Не ограничивайтесь генерированием
только исключения типа
RuntimeException. Найдите подходящий подкласс или создайте собственный.
Не перехватывайте исклю чение типа Throwable. При таком подходе ваш код
становится трудным для понимания и сопровождения.
Правильно различайте проверяемые и непроверяемые исключения. Для об­
работки проверяемых исключений требуются дополнительные усилия, поэто­
му не применяйте их для уведомления о логических ошибках. (В библиотеке,
поддерживающей механизм рефлексии, это правило не соблюдается. Поэтому
ее пользователям часто приходится писать код для перехвата тех исключений,
которые могут вообще не возникнуть.)
Смело преобразуйте, если требуется, один тип исключения в другой, более
подходящий в данной ситуации. Если вы, скажем, выполняете синтаксический
анализ целого значения, вводимого из файла, перехватывайте исключение
класса NumberFormatException и преобразуйте его в исклю чение подкласса,
производного от класса IOException или MySubsystemException, для после­
дующего генерирования.
4. Не подавляйте исключения.
При программировании на Java существует большой соблазн подавить ис­
ключения. Допустим, требуется написать метод, вызывающий другой метод,
который может сгенерировать исключение один раз в сто лет. Компилятор
предупредит об этом, поскольку исключение не указано в списке оператора
throws при объявлении данного метода. Но если нет никакого желания указы­
вать его в списке оператора throws, чтобы компилятор не выдавал сообщения
об ошибках во всех методах, вызывающих данный метод, то такое исключение
можно просто подавить следующим образом:
public Image loadlmage(String s)
{
try
{
код, способный генерировать проверяемые исключения
}
catch (Exception е)
{} // ничего не делать!
}
Теперь код будет скомпилирован. Он будет прекрасно работать, но не в исклю­
чительной ситуации. А если она возникнет, то будет просто проигнорирована.
Но если вы все-таки считаете, что подобные исключения важны, приложите
усилия для организации их обработки.
5. Обнаруживая ошибки, проявляйте необходимую твердость вместо излишней тер­
пимости.
Некоторые программисты избегают генерировать исключения, обнаруживая
ошибки. Например, если методу передаются некорректные параметры, они
предпочитают возвращать фиктивное значение. Когда, например, стек пуст,
программист может предусмотреть возврат из метода Stack.pop () пустого
значения null вместо того, чтобы генерировать исклю чение. На наш взгляд,
лучше сгенерировать исключение типа EmptyStackException в той точке, где
возникла ошибка, чем исключение типа NullPointerException впоследствии.
6. Не бойтесь передавать исключения для обработки в коде, разрабатываемом другими.
Некоторые программисты считают себя обязанными перехватывать все исклю­
чения. Вызывая метод, генерирующий некоторое исклю чение, например кон­
структор класса FilelnputStream или метод readLine ( ) , они инстинктивно
перехватывают исключения, которые могут быть при этом сгенерированы. Но
зачастую предпочтительнее передать исключение другому обработчику, а не
обрабатывать его самостоятельно, как показано ниже.
public void readStuff(String filename)
throws IOException // Ничтоже сумняшеся!
{
InputStream in = new FilelnputStream(filename);
}
Методы более высокого уровня лучше оснащены средствами уведомления
пользователей об ошибках или отмены выполнения неверных операций.

НА ЗАМЕТКУ! Рекомендации в пп.5 и 6 можно свести к следующему общему правилу: генерировать исключения раньше, а
перехватывать их позже.
----------------------------------------------------------------------------------------------------------------------
*/