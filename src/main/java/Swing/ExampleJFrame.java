package Examples.Swing;

import javax.swing.*;
import java.awt.*;

/**
 * @author Cay Horstmann
 * @version 1.33 2015-05-12
 */
public class ExampleJFrame {
    public static void main(String[] args) {
//---------------------------------------------------------------------------------------------------------------------
//        /*Имеются две технические трудности, которые приходится преодолевать каждой Swing-программе. Прежде всего, компоненты
//        Swing должны быть настроены в потоке диспетчеризации событий, т.е . в том потоке управления, который передает ком­
//        понентам пользовательского интерфейса события вроде щелчков кнопками мыши и нажатий клавиш. В следующем фрагменте
//        кода операторы выполняются в потоке диспетчеризации событий:*/
//        EventQueue.invokeLater(new Runnable() {
//            @Override
//            public void run() {
//                SimpleFrame frame = new SimpleFrame();
//                /*Далее в рассматриваемом здесь примере определяется, что именно должно произойти, если пользователь закроет
//                фрейм приложения. В данном случае программа должна завершить свою работу. Для этого служит следующая строка кода:*/
//                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//                //--------------------------------------------
//                /*С другой стороны, можно предоставить оконной системе возможность самой управлять расположением окон.
//                Так, если перед отображением окна сделать следующий вызов: setLoationByPlatform(true);*/
////                frame.setLocationByPlatform(true);
//                /*то оконная система сама выберет расположение (но не размеры) окна — как правило, с небольшим смещением
//                относительно предыдущего окна.*/
//                //---------------------------------------------
//                /*Для отображения фрейма на экране в методе main() вызывается метод setVisible().*/
//                frame.setVisible(true);
//                //----------------------------------------------
//                /*НА ЗАМЕТКУ! Все строки заголовка и другие элементы оформления фреймов можно отключить, сделав вызов
//                                        frame.setUndecorated(true).*/
////                frame.setUndecorated(true);
//                //----------------------------------------------
//                /*В классе JFrame имеется лишь несколько методов, позволяющих изменить внешний вид фрейма. Разумеется,
//                благодаря наследованию в классе JFrame можно использовать методы из его суперклассов, задающие размеры и
//                распоположение фрейма. К наиболее важным из них относятся следующие методы.
//                    • Методы setLocation() и setBounds(), устанавливающие положение фрейма.
//                    • Метод dispose(), закрывающий окно и освобождающий все системные ресурсы, использованные при его создании.
//                    • Метод setlconlmage(), сообщающий оконной системе, какая именно пиктограмма должна отображаться в
//                      строке заголовка, окне переключателя задач и т.п.
//                    • Метод setTitle(), позволяющий изменить текст в строке заголовка.
//                    • Метод setResizable(), получающий в качестве параметра логическое значение и определяющий, имеет ли
//                      пользователь право изменять размеры фрейма.
//
//                  НА ЗАМЕТКУ! Координаты расположения фрейма, задаваемые методами setLocation() и setBounds(), вычисляются
//                  относительно всего экрана. Как будет показано в главе 12, координаты других компонентов в контейнере
//                  определяются относительно самого контейнера.*/
////                Point point = new Point(650, 350);
////                frame.setLocation(point);
//                /*Аналогично метод setBounds() из класса Component позволяет одновременно изменить размер и расположение
//                компонента (в частности, объекта типа JFrame) с помощью следующего вызова: setBounds(х, у, width, height)*/
////                frame.setBounds(450,300,650,350);
//                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
//                frame.setBounds(screenSize.width/3,screenSize.height/3,650,350);
//
////                frame.dispose();
//                String path = "/root/Datos/Programacion/java_lessons/src/main/resources/Swing_Examples/icon.gif";
//                Image image = new ImageIcon(path).getImage();
//                frame.setIconImage(image);
//                frame.setTitle("My_App");
//                frame.setResizable(true);
////                frame.setResizable(false);
//                //------------------------------------------------
//            }
//        });
//---------------------------------------------------------------------------------------------------------------------
        EventQueue.invokeLater(() ->
        {
            /*Ниже дается ряд дополнительных рекомендаций по поводу обращения с фреймами.
                •Если фрейм содержит только стандартные компоненты вроде кнопок и текстовых полей, вызовите метод pack(),
                 чтобы установить размеры фрейма. Фрейм будет установлен с минимальными размерами, достаточными для размещения
                 всех его компонентов. Зачастую главный фрейм программы приходится устанавливать с максимальными размерами.
                 Фрейм можно развернуть до максимума, сделав следующий вызов:
                                        frame.setExtendedState(Frame.MAXIMIZED_BOTH);
                •Целесообразно также запоминать расположение и размеры фрейма, заданные пользователем, чтобы восстановить
                 эти значения при очередном запуске приложения. В главе 13 будет показано, как пользоваться для этой цели
                 прикладным программным интерфейсом Preferences API.
                •Если вы разрабатываете приложение, в котором выгодно используются преимущества многоэкранного дисплея,
                 применяйте классы GraphicsEnvironment и GraphicsDevice для определения размеров отдельных экранов.
                •Класс GraphicsDevice позволяет также выполнять приложение в полноэкранном режиме.*/
            JFrame frame = new SizedFrame();
            frame.setTitle("SizedFrame");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setVisible(true);
        });
//---------------------------------------------------------------------------------------------------------------------
//        JFrame jFrame = new JFrame(){};
//        jFrame.setVisible(true);
//        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//        //-----------------------------------------------------
//        // No dlya toho wob ne ykazuvat razmeru okna prelozenia(prilozenie mozet otkruvatsa na raznux po razmery ekranax)
//        // mozno ispolzovat toolKit eto nabor instrymentov dlia robotu s freimami nawoho prilozenia
//        Toolkit toolkit = Toolkit.getDefaultToolkit();
//        // iz toolkit mozem vziat demesion nawoho okna
//        // getScreenSize() vozvrawchaet wirinu i vusotu ekrana no kotorom zapyskaetsa prilozenie
//        Dimension demesion = toolkit.getScreenSize();
//
//        // V setBounds ukazuvaetsa razmer ramki i mestonaxozdenia ramki
////        jFrame.setBounds(500,300,500,300);
////        jFrame.setBounds(demesion.width/4,demesion.height/4,demesion.width/3,demesion.height/3);
//        jFrame.setBounds(demesion.width/2-250,demesion.height/2-150,demesion.width/3,demesion.height/3);
//        // setBounds ravnosilno etim dvom methodam
////        jFrame.setSize(500,300);
////        jFrame.setLocation(500,300);
//        //-----------------------------------------------------
//        jFrame.setTitle("MyApp");
//        jFrame.setIconImage(null);
//---------------------------------------------------------------------------------------------------------------------
    }
}

class SimpleFrame extends JFrame {
    private static final int DEFAULT_WIDTH = 300;
    private static final int DEFAULT_HEIGHT = 200;

    public SimpleFrame() {
        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
    }
}

/**
 * @author Cay Horstmann
 * @version 1.34 2015-06-16
 */
class SizedFrame extends JFrame {
    public SizedFrame() {
        // get screen dimensions

        Toolkit kit = Toolkit.getDefaultToolkit();
        Dimension screenSize = kit.getScreenSize();
        int screenHeight = screenSize.height;
        int screenWidth = screenSize.width;

        // set frame width, height and let platform pick screen location

//        setSize(screenWidth / 3, screenHeight / 3);
//        setLocation(screenWidth/3, screenHeight/3);
//        setLocationByPlatform(true);
        setExtendedState(Frame.MAXIMIZED_BOTH);  // vidkruvaetsa frame na celyy stranicy

        // set frame icon

        String path = "/root/Datos/Programacion/java_lessons/src/main/resources/Swing_Examples/icon.gif";
        Image img = new ImageIcon(path).getImage();
        setIconImage(img);
    }
}

/*
-----------------------------------------------------------------------------------------------------------------------
В языке Java фреймы предназначены именно для того, чтобы служить контейнерами для компонентов (например, меню или других
элементов пользовательского интерфейса). Как правило, рисунки выводятся в другом компоненте, который добавляется во фрейм.
-----------------------------------------------------------------------------------------------------------------------
Оказывается, что структура класса JFrame довольно сложная. Его внутреннее строение показано на рис. 10.8. Как видите, класс
JFrame состоит из четырех областей, каждая из которых представляет собой отдельную панель. Корневая, многослойная и прозрач­
ная панели не представляют особого интереса. Они нужны лишь для оформления меню и панели содержимого в определенном стиле.
Наиболее интересной для применения библиотеки Swing является панель содержимого. При оформлении фрейма его компоненты
добавляются на панели содержимого с помощью следующего кода:
                        Container contentPane = frame.getContentPane();
                        Component c =...
                        contentPane.add(c) ;
-----------------------------------------------------------------------------------------------------------------------
СОВЕТ. В конце этого раздела описаны наиболее важные методы, позволяющие изменять внешний
вид фреймов. Одни из них определены в классе JFrame, а другие — в различных суперклассах
этого класса. В процессе разработки приложений часто приходится выбирать наиболее подходя­
щий метод для решения той или иной задачи. К сожалению, найти нужные сведения в документа­
ции на JDK не так-то просто, особенно о переопределяемых методах. Например, метод toFront ()
можно применять к объектам типа JFrame, но поскольку он наследуется от класса Window, то
в документации на класс JFrame о нем ничего не сказано. Так, если вы предполагаете, что не­
который метод должен существовать, а в документации на класс, с которым вы работаете, он от­
сутствует, обратитесь к описанию методов с у п е р к л а с с о в этого класса. В начале каждой страницы
документации на прикладной программный интерфейс API имеются гипертекстовые ссылки на су­
перклассы. После описания новых и переопределенных методов в документации приводится также
список всех наследуемых методов.
-----------------------------------------------------------------------------------------------------------------------
•Container getContentPane()
    Возвращает панель содержимого для данного объекта типа JFrame.

•Component add(Component с)
    Добавляет указанный компонент на панели содержимого данного фрейма. (До версии Java SE 5.0
    вызов этого метода приводил к генерированию исключения.)
-----------------------------------------------------------------------------------------------------------------------
*/
