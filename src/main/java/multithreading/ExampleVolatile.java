package multithreading;

public class ExampleVolatile {

    private final static int N = 1_000_000;
    private volatile static int counter = 0;

    public static void main(String[] args) {
//---------------------------------Ne-Prevelnoe-rewenie--------------------------------------------------
        Thread thread_1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < N; i++) {
                    counter++;
                }
            }
        });

        Thread thread_2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < N; i++) {
                    counter++;
                }
            }
        });

        thread_1.start();
        thread_2.start();

        try {
            thread_1.join();
            thread_2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(counter);
//-------------------------------------------------------------------------------------------------------------------
    }
}

/*
 * -----------------------------------------------------------------------------
 * Разделяемые переменные могут быть объявлены как volatile, при условии, что над
 * ними не выполняется никаких операций, кроме присваивания.
 * -----------------------------------------------------------------------------
 * ------------------------------------------- Ключевое слово volatile
 * обозначает неблокирующий механизм си нхронизиро­ ванного доступа к полю
 * экземпляра. Если поле объявляется как volatile, то ком­пилятор и виртуальная
 * машина принимают во внимание тот факт, что поле может быть параллельно
 * обновлено в другом потоке исполнения.
 * -----------------------------------------------------------------------------
 * ------------------------------------------- ВНИМАНИЕ! Изменчивые переменные
 * типа volatile не гарантируют никакой атомарности опера­ ций. Например,
 * приведенный ниже метод не гарантирует смены значения поля на противоположное.
 * public void flipDone() { done = Idone; } //не атомарная операция!
 * -----------------------------------------------------------------------------
 * ------------------------------------------- НА ЗАМЕТКУ! Брайан Гоетц
 * предложил следующий "девиз синхронизации”: если вы записываете в переменную
 * данные, которые могут быть затем прочитаны в другом потоке исполнения, или же
 * читаете из переменной данные, которые были записаны в другом потоке
 * исполнения, то обязаны использовать синхронизацию.
 * -----------------------------------------------------------------------------
 * -------------------------------------------
 */
