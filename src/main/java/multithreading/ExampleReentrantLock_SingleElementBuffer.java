package Examples.Multithreading;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;


// 1) fairness
// 2) lock/unlock - nezavisimue
public class ExampleReentrantLock_SingleElementBuffer {
    // Esli ReentrantLock(false)po ymolchaniy on false  to wait-set i bloked-set rabotayt kak v syncronized,
    // a esli ReentrantLock(true) to v wait-set i bloked-set rabotaet v stile FIFO, toest pervui potok
    // kotorui vowol v wait-set ili v bloked-set pervum vuidet po zaprosy JVM.
    // Dryhimi slovami esli ReentrantLock(false) to on rabotaet wait-set bloked-set
    // a esli               ReentrantLock(true) to on rabotaet wait-queue bloked-queue
    private final Lock lock = new ReentrantLock(true);  // fairness
    /*С объектом блокировки может быть связан один или несколько объектов условий, которые получены с помощью метода
     * new Condition(). Каждому объекту условия можно присвоить имя, напоминающее об условии, которое он представляет.*/
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private Integer element = null;

    public void put(int newElement) throws InterruptedException {
        lock.lock();
        try {
            while (this.element != null) {
                // Текущий поток исполнения теперь деактивизирован и снимает блокировку.
                notFull.await();   // await() not wait()
            }
            this.element = newElement;
            notEmpty.signal();    // signal() not signalALL()
        } finally {
            lock.unlock();
        }
    }

    // Etot metod takoize samui kak vuwe no imeet ewcho odno svoistvo, esli monitor zaxvachen to etot
    // metod vozvrawchaet false a esli ne zaxvachen monitor to metod vozvrawchaet true
    public boolean tryPut(int newElement) throws InterruptedException {
        lock.lock();
        if (lock.tryLock()) {
            try {
                while (this.element != null) {
                    notFull.await();   // await() not wait()
                }
                this.element = newElement;
                notEmpty.signal();    // signal() not signalALL()
            } finally {
                lock.unlock();
                return true;
            }
        } else {
            return false;
        }
    }

    // A zdes lock.tryLock(timeOut, units) rabotaet s taimautom
    public boolean tryPut(int newElement, long timeOut, TimeUnit units) throws InterruptedException {
        lock.lock();
        if (lock.tryLock(timeOut, units)) {
            try {
                while (this.element != null) {
                    notFull.await();   // await() not wait()
                }
                this.element = newElement;
                notEmpty.signal();    // signal() not signalALL()
            } finally {
                lock.unlock();
                return true;
            }
        } else {
            return false;
        }
    }


    public int get() throws InterruptedException {
        lock.lock();
        try {
            while (element == null) {
                notEmpty.await();  // await() not wait()
            }
            Integer result = this.element;
            this.element = null;
            notFull.signal();     // signal() not signalAll()
            return result;
        } finally {
            lock.unlock();
        }
    }

}

/*
------------------------------------------------------------------------------------------------------------------------------
*Имеется существенное отличие между потоком, ожидающим возможности за­хватить блокировку, и потоком, который 
* вызвал метод await(). Как только в потоке исполнения вызывается метод await(), он входит в набор ожидания, 
* установленный для данного условия. Поток не становится исполняемым, когда оказывается доступ­ной блокировка. 
* Вместо этого он остается деактивизированным до тех пор, пока дру­гой поток не вызовет метод signalАll() по * тому же условию.
* 
* В результате этого вызова активизируются все потоки исполнения, ожидающие данного условия. Когда потоки удаляются
* из набора ожидания, они опять становятся исполняемыми, и в конечном итоге планировщик потоков активизирует их 
* снова. В этот момент они попытаются повторно захватить объект блокировки. И как толь­ко он окажется доступным, 
* один из этих потоков захватит блокировку и продолжит свое исполнение с того места, где он остановился, получив 
* управление после вызова метода await().
* В этот момент условие должно быть снова проверено в потоке исполнения. Но нет никаких гарантий, что условие 
* теперь выполнится. Ведь метод signalAll() просто сигнализирует ожидающим потокам о том, что условие теперь 
* может быть удовлет­ ворено и что его стоит проверить заново.
* 
* Когда же следует вызывать метод signalAll()? Существует эмпирическое пра­вило: вызывать этот метод при таком 
* изменении состояния объекта, которое может быть выгодно ож идающим потокам исполнения. Например, всякий раз, 
* когда из­ меняются остатки на счетах, ожидающим потокам исполнения следует давать оче­редную возможность для 
* проверки остатков на счетах.
------------------------------------------------------------------------------------------------------------------------------
ВНИМАНИЕ! По условию в потоке исполнения может быть вызван только метод await(), signalAll() или signal(), когда этот поток 
владеет блокировкой по данному условию.
------------------------------------------------------------------------------------------------------------------------------
ВНИМАНИЕ! На первый взгляд, лучше, чтобы блокировка была равноправной, но равноправные блокировки действуют намного медленнее 
обычных. Разрешить равноправную блокировку вы мо­жете только в том случае, если точно знаете, что делаете, и имеете на то 
особые причины. Даже если вы используете равноправную блокировку, у вас все равно нет никаких гарантий, что плани­ровщик потоков
будет такж е соблюдать правило равноправия. Если планировщик потоков решит пренебречь потоком исполнения, который длительное 
время ожидает снятия блокировки, то ни ка­кое равноправие блокировок не поможет.
------------------------------------------------------------------------------------------------------------------------------
Что же лучше использовать в прикладном коде: объекты типа Lock и Condition или синхронизированные методы? Ниже приведены 
некоторые рекомендации, кото­рые дают ответ на этот вопрос.
	• Лучше не пользоваться ни объектами типа Lock/Condition, ни ключевым словом synchronized. Зачастую вместо этого можно 
	  выбрать подходящий механизм из пакета java.util.concurrent, который организует блокировку автоматически. Так, в разделе 
	  14.6 далее в этой главе будет показано, как поль­зоваться блокирующими очередями для синхронизации потоков, выполняю­
	  щих общую задачу.
	• Если ключевое слово synchronized подходит в конкретной ситуации, непре­менно воспользуйтесь им. В этом случае вам 
	  придется написать меньше кода,а следовательно, допустить меньше ошибок. В листинге 14.8 приведен пример очередного 
	  варианта программы, имитирующей банк и реализованной на ос­нове синхронизированных методов.
	• Пользуйтесь объектами типа Lock/Condition, если действительно нуждаетесь
	  в дополнительных возможностях подобных конструкций.
------------------------------------------------------------------------------------------------------------------------------
В предыдущих разделах было показано, как пользоваться объектами блокировки типа Lock и условиями типа Condition. Прежде чем 
двигаться дальше, подведем краткие итоги, перечислив главные особенности блокировок и условий.
	• Блокировка защищает критические разделы кода, позволяя выполнять этот код только в одном потоке в единицу времени.
	• Блокировка управляет потоками исполнения, которые пытаются войти в защи­щенный раздел кода.
	• Каждый объект условия управляет потоками, которые вошли в защищенный раздел кода, но пока 
	  еще не в состоянии продолжить свое исполнение.
------------------------------------------------------------------------------------------------------------------------------
•ReentrantLock()
	Конструирует объект реентерабельной блокировки, которая может быть использована для защиты критического раздела кода.
	
•ReentrantLock(boolean fair)
	Конструирует объект реентерабельной блокировки с заданным правилом равноправия. Равноправ­ная блокировка отдает 
	предпочтение потоку исполнения, ожидающему дольше всех. Но такое рав­ноправие может отрицательно сказаться на 
	производительности. Поэтому по умолчанию равнопра­вия от блокировок не требуется.
------------------------------------------------------------------------------------------------------------------------------
*/
