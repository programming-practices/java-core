package multithreading;

public class ExampleReentrantReadWriteLock {

    public static void main(String[] args) {

    }

}

/*
------------------------------------------------------------------------------------------------------------------
Etot klas ydoben v tex slychaiax, когда имеется больше потоков для чтения из струк­туры данных и меньше потоков 
для записи в нее. В подобных случаях имеет смысл разрешить совместный доступ читающим потокам исполнения. 
Безусловно, записы­ вающий поток должен по-прежнему иметь исключительный доступ. Ниже описаны действия, которые 
следует предпринять для организации блоки­ровок чтения/записи.
	1. Сконструируйте объект типа ReentrantReadWriteLock:
			private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock!);
	2. Извлеките блокировки чтения и записи:
			private Lock readLock = rwl .readLock();
			private Lock writeLock = rwl.writeLock();
	3. Используйте блокировку чтения во всех методах доступа:
			public double getTotalBalance(){
				readLock.lock();
				try{...}
				finally { readLock.unlock() ; }
			}
	4. Используйте блокировку записи во всех модифицирующих методах:
			public void transfer!. . .){
				writeLock.lock();
				try{...}
				finally { writeLock.unlock() ; }
			}
------------------------------------------------------------------------------------------------------------------
•Lock readLock()
	Получает блокировку чтения, которая может быть захвачена многими читающими потоками, но ис­
	ключая все записывающие потоки.
	
•Lock writeLock()
	Получает блокировку записи, исключающую доступ для всех читающих и остальных записывающих потоков.
------------------------------------------------------------------------------------------------------------------
*/
